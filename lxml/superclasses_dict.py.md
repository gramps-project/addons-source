#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Jul  5 15:10:06 2015 by generateDS.py version 2.16a.
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)
PRESERVE_CDATA_TAGS_PAT = re_.compile(r'^<.+?>(.*)<.+>$')


#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


PRESERVE_CDATA_TAGS_PAT1 = re_.compile(r'^<.+?>(.*?)</?[a-zA-Z0-9\-]+>.*$')
PRESERVE_CDATA_TAGS_PAT2 = re_.compile(r'^<.+?>.*?</.+?>(.*)$')


def get_all_text_(node):
    if node.text is not None:
        mo_ = PRESERVE_CDATA_TAGS_PAT1.search(etree_.tostring(node).strip())
        if mo_ is not None:
            text = mo_.group(1)
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            mo_ = PRESERVE_CDATA_TAGS_PAT2.search(
                etree_.tostring(child).strip())
            if mo_ is not None:
                text += mo_.group(1)
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class database(GeneratedsSuper):
    member_data_items_ = {
        'header': MemberSpec_('header', 'header', 0),
        'name_formats': MemberSpec_('name_formats', 'name-formats', 0),
        'tags': MemberSpec_('tags', 'tags', 0),
        'events': MemberSpec_('events', 'events', 0),
        'people': MemberSpec_('people', 'people', 0),
        'families': MemberSpec_('families', 'families', 0),
        'citations': MemberSpec_('citations', 'citations', 0),
        'sources': MemberSpec_('sources', 'sources', 0),
        'places': MemberSpec_('places', 'places', 0),
        'objects': MemberSpec_('objects', 'objects', 0),
        'repositories': MemberSpec_('repositories', 'repositories', 0),
        'notes': MemberSpec_('notes', 'notes', 0),
        'bookmarks': MemberSpec_('bookmarks', 'bookmarks', 0),
        'namemaps': MemberSpec_('namemaps', 'namemaps', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, header=None, name_formats=None, tags=None, events=None, people=None, families=None, citations=None, sources=None, places=None, objects=None, repositories=None, notes=None, bookmarks=None, namemaps=None):
        self.original_tagname_ = None
        self.header = header
        self.name_formats = name_formats
        self.tags = tags
        self.events = events
        self.people = people
        self.families = families
        self.citations = citations
        self.sources = sources
        self.places = places
        self.objects = objects
        self.repositories = repositories
        self.notes = notes
        self.bookmarks = bookmarks
        self.namemaps = namemaps
    def factory(*args_, **kwargs_):
        if database.subclass:
            return database.subclass(*args_, **kwargs_)
        else:
            return database(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_header(self): return self.header
    def set_header(self, header): self.header = header
    def get_name_formats(self): return self.name_formats
    def set_name_formats(self, name_formats): self.name_formats = name_formats
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def get_events(self): return self.events
    def set_events(self, events): self.events = events
    def get_people(self): return self.people
    def set_people(self, people): self.people = people
    def get_families(self): return self.families
    def set_families(self, families): self.families = families
    def get_citations(self): return self.citations
    def set_citations(self, citations): self.citations = citations
    def get_sources(self): return self.sources
    def set_sources(self, sources): self.sources = sources
    def get_places(self): return self.places
    def set_places(self, places): self.places = places
    def get_objects(self): return self.objects
    def set_objects(self, objects): self.objects = objects
    def get_repositories(self): return self.repositories
    def set_repositories(self, repositories): self.repositories = repositories
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_bookmarks(self): return self.bookmarks
    def set_bookmarks(self, bookmarks): self.bookmarks = bookmarks
    def get_namemaps(self): return self.namemaps
    def set_namemaps(self, namemaps): self.namemaps = namemaps
    def hasContent_(self):
        if (
            self.header is not None or
            self.name_formats is not None or
            self.tags is not None or
            self.events is not None or
            self.people is not None or
            self.families is not None or
            self.citations is not None or
            self.sources is not None or
            self.places is not None or
            self.objects is not None or
            self.repositories is not None or
            self.notes is not None or
            self.bookmarks is not None or
            self.namemaps is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='database', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='database')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='database', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='database'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='database', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            self.header.export(outfile, level, namespace_='gramps:', name_='header', pretty_print=pretty_print)
        if self.name_formats is not None:
            self.name_formats.export(outfile, level, namespace_='gramps:', name_='name-formats', pretty_print=pretty_print)
        if self.tags is not None:
            self.tags.export(outfile, level, namespace_='gramps:', name_='tags', pretty_print=pretty_print)
        if self.events is not None:
            self.events.export(outfile, level, namespace_='gramps:', name_='events', pretty_print=pretty_print)
        if self.people is not None:
            self.people.export(outfile, level, namespace_='gramps:', name_='people', pretty_print=pretty_print)
        if self.families is not None:
            self.families.export(outfile, level, namespace_='gramps:', name_='families', pretty_print=pretty_print)
        if self.citations is not None:
            self.citations.export(outfile, level, namespace_='gramps:', name_='citations', pretty_print=pretty_print)
        if self.sources is not None:
            self.sources.export(outfile, level, namespace_='gramps:', name_='sources', pretty_print=pretty_print)
        if self.places is not None:
            self.places.export(outfile, level, namespace_='gramps:', name_='places', pretty_print=pretty_print)
        if self.objects is not None:
            self.objects.export(outfile, level, namespace_='gramps:', name_='objects', pretty_print=pretty_print)
        if self.repositories is not None:
            self.repositories.export(outfile, level, namespace_='gramps:', name_='repositories', pretty_print=pretty_print)
        if self.notes is not None:
            self.notes.export(outfile, level, namespace_='gramps:', name_='notes', pretty_print=pretty_print)
        if self.bookmarks is not None:
            self.bookmarks.export(outfile, level, namespace_='gramps:', name_='bookmarks', pretty_print=pretty_print)
        if self.namemaps is not None:
            self.namemaps.export(outfile, level, namespace_='gramps:', name_='namemaps', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='database'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.header is not None:
            showIndent(outfile, level)
            outfile.write('header=model_.header(\n')
            self.header.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.name_formats is not None:
            showIndent(outfile, level)
            outfile.write('name_formats=model_.name_formats(\n')
            self.name_formats.exportLiteral(outfile, level, name_='name_formats')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tags is not None:
            showIndent(outfile, level)
            outfile.write('tags=model_.tags(\n')
            self.tags.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.events is not None:
            showIndent(outfile, level)
            outfile.write('events=model_.events(\n')
            self.events.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.people is not None:
            showIndent(outfile, level)
            outfile.write('people=model_.people(\n')
            self.people.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.families is not None:
            showIndent(outfile, level)
            outfile.write('families=model_.families(\n')
            self.families.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.citations is not None:
            showIndent(outfile, level)
            outfile.write('citations=model_.citations(\n')
            self.citations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sources is not None:
            showIndent(outfile, level)
            outfile.write('sources=model_.sources(\n')
            self.sources.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.places is not None:
            showIndent(outfile, level)
            outfile.write('places=model_.places(\n')
            self.places.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.objects is not None:
            showIndent(outfile, level)
            outfile.write('objects=model_.objects(\n')
            self.objects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.repositories is not None:
            showIndent(outfile, level)
            outfile.write('repositories=model_.repositories(\n')
            self.repositories.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.notes(\n')
            self.notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bookmarks is not None:
            showIndent(outfile, level)
            outfile.write('bookmarks=model_.bookmarks(\n')
            self.bookmarks.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.namemaps is not None:
            showIndent(outfile, level)
            outfile.write('namemaps=model_.namemaps(\n')
            self.namemaps.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'header':
            obj_ = header.factory()
            obj_.build(child_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'name-formats':
            obj_ = name_formats.factory()
            obj_.build(child_)
            self.name_formats = obj_
            obj_.original_tagname_ = 'name-formats'
        elif nodeName_ == 'tags':
            obj_ = tags.factory()
            obj_.build(child_)
            self.tags = obj_
            obj_.original_tagname_ = 'tags'
        elif nodeName_ == 'events':
            obj_ = events.factory()
            obj_.build(child_)
            self.events = obj_
            obj_.original_tagname_ = 'events'
        elif nodeName_ == 'people':
            obj_ = people.factory()
            obj_.build(child_)
            self.people = obj_
            obj_.original_tagname_ = 'people'
        elif nodeName_ == 'families':
            obj_ = families.factory()
            obj_.build(child_)
            self.families = obj_
            obj_.original_tagname_ = 'families'
        elif nodeName_ == 'citations':
            obj_ = citations.factory()
            obj_.build(child_)
            self.citations = obj_
            obj_.original_tagname_ = 'citations'
        elif nodeName_ == 'sources':
            obj_ = sources.factory()
            obj_.build(child_)
            self.sources = obj_
            obj_.original_tagname_ = 'sources'
        elif nodeName_ == 'places':
            obj_ = places.factory()
            obj_.build(child_)
            self.places = obj_
            obj_.original_tagname_ = 'places'
        elif nodeName_ == 'objects':
            obj_ = objects.factory()
            obj_.build(child_)
            self.objects = obj_
            obj_.original_tagname_ = 'objects'
        elif nodeName_ == 'repositories':
            obj_ = repositories.factory()
            obj_.build(child_)
            self.repositories = obj_
            obj_.original_tagname_ = 'repositories'
        elif nodeName_ == 'notes':
            obj_ = notes.factory()
            obj_.build(child_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'bookmarks':
            obj_ = bookmarks.factory()
            obj_.build(child_)
            self.bookmarks = obj_
            obj_.original_tagname_ = 'bookmarks'
        elif nodeName_ == 'namemaps':
            obj_ = namemaps.factory()
            obj_.build(child_)
            self.namemaps = obj_
            obj_.original_tagname_ = 'namemaps'
# end class database


class header(GeneratedsSuper):
    member_data_items_ = {
        'created': MemberSpec_('created', 'created', 0),
        'researcher': MemberSpec_('researcher', 'researcher', 0),
        'mediapath': MemberSpec_('mediapath', 'mediapath', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, created=None, researcher=None, mediapath=None):
        self.original_tagname_ = None
        self.created = created
        self.researcher = researcher
        self.mediapath = mediapath
    def factory(*args_, **kwargs_):
        if header.subclass:
            return header.subclass(*args_, **kwargs_)
        else:
            return header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_researcher(self): return self.researcher
    def set_researcher(self, researcher): self.researcher = researcher
    def get_mediapath(self): return self.mediapath
    def set_mediapath(self, mediapath): self.mediapath = mediapath
    def hasContent_(self):
        if (
            self.created is not None or
            self.researcher is not None or
            self.mediapath is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='header', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='header')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='header', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='header'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='header', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.created is not None:
            self.created.export(outfile, level, namespace_='gramps:', name_='created', pretty_print=pretty_print)
        if self.researcher is not None:
            self.researcher.export(outfile, level, namespace_='gramps:', name_='researcher', pretty_print=pretty_print)
        if self.mediapath is not None:
            self.mediapath.export(outfile, level, namespace_='gramps:', name_='mediapath', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='header'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('created=model_.created(\n')
            self.created.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.researcher is not None:
            showIndent(outfile, level)
            outfile.write('researcher=model_.researcher(\n')
            self.researcher.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mediapath is not None:
            showIndent(outfile, level)
            outfile.write('mediapath=model_.mediapath(\n')
            self.mediapath.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'created':
            obj_ = created.factory()
            obj_.build(child_)
            self.created = obj_
            obj_.original_tagname_ = 'created'
        elif nodeName_ == 'researcher':
            obj_ = researcher.factory()
            obj_.build(child_)
            self.researcher = obj_
            obj_.original_tagname_ = 'researcher'
        elif nodeName_ == 'mediapath':
            obj_ = mediapath.factory()
            obj_.build(child_)
            self.mediapath = obj_
            obj_.original_tagname_ = 'mediapath'
# end class header


class created(GeneratedsSuper):
    member_data_items_ = {
        'date': MemberSpec_('date', 'string', 0),
        'version': MemberSpec_('version', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, date=None, version=None):
        self.original_tagname_ = None
        self.date = _cast(None, date)
        self.version = _cast(None, version)
    def factory(*args_, **kwargs_):
        if created.subclass:
            return created.subclass(*args_, **kwargs_)
        else:
            return created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='created', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='created')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='created', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='created'):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_format_string(quote_attrib(self.date).encode(ExternalEncoding), input_name='date'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='created', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='created'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            showIndent(outfile, level)
            outfile.write('date="%s",\n' % (self.date,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class created


class researcher(GeneratedsSuper):
    member_data_items_ = {
        'resname': MemberSpec_('resname', 'resname', 0),
        'resaddr': MemberSpec_('resaddr', 'resaddr', 0),
        'reslocality': MemberSpec_('reslocality', 'reslocality', 0),
        'rescity': MemberSpec_('rescity', 'rescity', 0),
        'resstate': MemberSpec_('resstate', 'resstate', 0),
        'rescountry': MemberSpec_('rescountry', 'rescountry', 0),
        'respostal': MemberSpec_('respostal', 'respostal', 0),
        'resphone': MemberSpec_('resphone', 'resphone', 0),
        'resemail': MemberSpec_('resemail', 'resemail', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resname=None, resaddr=None, reslocality=None, rescity=None, resstate=None, rescountry=None, respostal=None, resphone=None, resemail=None):
        self.original_tagname_ = None
        self.resname = resname
        self.resaddr = resaddr
        self.reslocality = reslocality
        self.rescity = rescity
        self.resstate = resstate
        self.rescountry = rescountry
        self.respostal = respostal
        self.resphone = resphone
        self.resemail = resemail
    def factory(*args_, **kwargs_):
        if researcher.subclass:
            return researcher.subclass(*args_, **kwargs_)
        else:
            return researcher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resname(self): return self.resname
    def set_resname(self, resname): self.resname = resname
    def get_resaddr(self): return self.resaddr
    def set_resaddr(self, resaddr): self.resaddr = resaddr
    def get_reslocality(self): return self.reslocality
    def set_reslocality(self, reslocality): self.reslocality = reslocality
    def get_rescity(self): return self.rescity
    def set_rescity(self, rescity): self.rescity = rescity
    def get_resstate(self): return self.resstate
    def set_resstate(self, resstate): self.resstate = resstate
    def get_rescountry(self): return self.rescountry
    def set_rescountry(self, rescountry): self.rescountry = rescountry
    def get_respostal(self): return self.respostal
    def set_respostal(self, respostal): self.respostal = respostal
    def get_resphone(self): return self.resphone
    def set_resphone(self, resphone): self.resphone = resphone
    def get_resemail(self): return self.resemail
    def set_resemail(self, resemail): self.resemail = resemail
    def hasContent_(self):
        if (
            self.resname is not None or
            self.resaddr is not None or
            self.reslocality is not None or
            self.rescity is not None or
            self.resstate is not None or
            self.rescountry is not None or
            self.respostal is not None or
            self.resphone is not None or
            self.resemail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='researcher', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='researcher')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='researcher', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='researcher'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='researcher', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resname is not None:
            self.resname.export(outfile, level, namespace_='gramps:', name_='resname', pretty_print=pretty_print)
        if self.resaddr is not None:
            self.resaddr.export(outfile, level, namespace_='gramps:', name_='resaddr', pretty_print=pretty_print)
        if self.reslocality is not None:
            self.reslocality.export(outfile, level, namespace_='gramps:', name_='reslocality', pretty_print=pretty_print)
        if self.rescity is not None:
            self.rescity.export(outfile, level, namespace_='gramps:', name_='rescity', pretty_print=pretty_print)
        if self.resstate is not None:
            self.resstate.export(outfile, level, namespace_='gramps:', name_='resstate', pretty_print=pretty_print)
        if self.rescountry is not None:
            self.rescountry.export(outfile, level, namespace_='gramps:', name_='rescountry', pretty_print=pretty_print)
        if self.respostal is not None:
            self.respostal.export(outfile, level, namespace_='gramps:', name_='respostal', pretty_print=pretty_print)
        if self.resphone is not None:
            self.resphone.export(outfile, level, namespace_='gramps:', name_='resphone', pretty_print=pretty_print)
        if self.resemail is not None:
            self.resemail.export(outfile, level, namespace_='gramps:', name_='resemail', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='researcher'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resname is not None:
            showIndent(outfile, level)
            outfile.write('resname=model_.resname(\n')
            self.resname.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resaddr is not None:
            showIndent(outfile, level)
            outfile.write('resaddr=model_.resaddr(\n')
            self.resaddr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reslocality is not None:
            showIndent(outfile, level)
            outfile.write('reslocality=model_.reslocality(\n')
            self.reslocality.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rescity is not None:
            showIndent(outfile, level)
            outfile.write('rescity=model_.rescity(\n')
            self.rescity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resstate is not None:
            showIndent(outfile, level)
            outfile.write('resstate=model_.resstate(\n')
            self.resstate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rescountry is not None:
            showIndent(outfile, level)
            outfile.write('rescountry=model_.rescountry(\n')
            self.rescountry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.respostal is not None:
            showIndent(outfile, level)
            outfile.write('respostal=model_.respostal(\n')
            self.respostal.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resphone is not None:
            showIndent(outfile, level)
            outfile.write('resphone=model_.resphone(\n')
            self.resphone.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resemail is not None:
            showIndent(outfile, level)
            outfile.write('resemail=model_.resemail(\n')
            self.resemail.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resname':
            obj_ = resname.factory()
            obj_.build(child_)
            self.resname = obj_
            obj_.original_tagname_ = 'resname'
        elif nodeName_ == 'resaddr':
            obj_ = resaddr.factory()
            obj_.build(child_)
            self.resaddr = obj_
            obj_.original_tagname_ = 'resaddr'
        elif nodeName_ == 'reslocality':
            obj_ = reslocality.factory()
            obj_.build(child_)
            self.reslocality = obj_
            obj_.original_tagname_ = 'reslocality'
        elif nodeName_ == 'rescity':
            obj_ = rescity.factory()
            obj_.build(child_)
            self.rescity = obj_
            obj_.original_tagname_ = 'rescity'
        elif nodeName_ == 'resstate':
            obj_ = resstate.factory()
            obj_.build(child_)
            self.resstate = obj_
            obj_.original_tagname_ = 'resstate'
        elif nodeName_ == 'rescountry':
            obj_ = rescountry.factory()
            obj_.build(child_)
            self.rescountry = obj_
            obj_.original_tagname_ = 'rescountry'
        elif nodeName_ == 'respostal':
            obj_ = respostal.factory()
            obj_.build(child_)
            self.respostal = obj_
            obj_.original_tagname_ = 'respostal'
        elif nodeName_ == 'resphone':
            obj_ = resphone.factory()
            obj_.build(child_)
            self.resphone = obj_
            obj_.original_tagname_ = 'resphone'
        elif nodeName_ == 'resemail':
            obj_ = resemail.factory()
            obj_.build(child_)
            self.resemail = obj_
            obj_.original_tagname_ = 'resemail'
# end class researcher


class resname(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resname.subclass:
            return resname.subclass(*args_, **kwargs_)
        else:
            return resname(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='resname', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resname')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='resname'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='resname', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='resname'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class resname


class resaddr(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resaddr.subclass:
            return resaddr.subclass(*args_, **kwargs_)
        else:
            return resaddr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='resaddr', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resaddr')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='resaddr'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='resaddr', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='resaddr'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class resaddr


class reslocality(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reslocality.subclass:
            return reslocality.subclass(*args_, **kwargs_)
        else:
            return reslocality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='reslocality', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reslocality')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='reslocality'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='reslocality', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='reslocality'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class reslocality


class rescity(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if rescity.subclass:
            return rescity.subclass(*args_, **kwargs_)
        else:
            return rescity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='rescity', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rescity')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='rescity'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='rescity', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rescity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class rescity


class resstate(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resstate.subclass:
            return resstate.subclass(*args_, **kwargs_)
        else:
            return resstate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='resstate', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resstate')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='resstate'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='resstate', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='resstate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class resstate


class rescountry(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if rescountry.subclass:
            return rescountry.subclass(*args_, **kwargs_)
        else:
            return rescountry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='rescountry', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rescountry')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='rescountry'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='rescountry', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rescountry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class rescountry


class respostal(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if respostal.subclass:
            return respostal.subclass(*args_, **kwargs_)
        else:
            return respostal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='respostal', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='respostal')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='respostal'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='respostal', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='respostal'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class respostal


class resphone(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resphone.subclass:
            return resphone.subclass(*args_, **kwargs_)
        else:
            return resphone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='resphone', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resphone')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='resphone'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='resphone', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='resphone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class resphone


class resemail(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resemail.subclass:
            return resemail.subclass(*args_, **kwargs_)
        else:
            return resemail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='resemail', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resemail')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='resemail'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='resemail', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='resemail'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class resemail


class mediapath(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if mediapath.subclass:
            return mediapath.subclass(*args_, **kwargs_)
        else:
            return mediapath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='mediapath', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mediapath')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='mediapath'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='mediapath', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mediapath'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class mediapath


class people(GeneratedsSuper):
    member_data_items_ = {
        'default': MemberSpec_('default', 'string', 0),
        'home': MemberSpec_('home', 'string', 0),
        'person': MemberSpec_('person', 'person', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, home=None, person=None):
        self.original_tagname_ = None
        self.default = _cast(None, default)
        self.home = _cast(None, home)
        if person is None:
            self.person = []
        else:
            self.person = person
    def factory(*args_, **kwargs_):
        if people.subclass:
            return people.subclass(*args_, **kwargs_)
        else:
            return people(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_person(self): return self.person
    def set_person(self, person): self.person = person
    def add_person(self, value): self.person.append(value)
    def insert_person_at(self, index, value): self.person.insert(index, value)
    def replace_person_at(self, index, value): self.person[index] = value
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_home(self): return self.home
    def set_home(self, home): self.home = home
    def hasContent_(self):
        if (
            self.person
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='people', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='people')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='people', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='people'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.home is not None and 'home' not in already_processed:
            already_processed.add('home')
            outfile.write(' home=%s' % (self.gds_format_string(quote_attrib(self.home).encode(ExternalEncoding), input_name='home'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='people', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for person_ in self.person:
            person_.export(outfile, level, namespace_='gramps:', name_='person', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='people'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            showIndent(outfile, level)
            outfile.write('default="%s",\n' % (self.default,))
        if self.home is not None and 'home' not in already_processed:
            already_processed.add('home')
            showIndent(outfile, level)
            outfile.write('home="%s",\n' % (self.home,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('person=[\n')
        level += 1
        for person_ in self.person:
            showIndent(outfile, level)
            outfile.write('model_.person(\n')
            person_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            self.default = value
        value = find_attr_value_('home', node)
        if value is not None and 'home' not in already_processed:
            already_processed.add('home')
            self.home = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'person':
            obj_ = person.factory()
            obj_.build(child_)
            self.person.append(obj_)
            obj_.original_tagname_ = 'person'
# end class people


class person(GeneratedsSuper):
    member_data_items_ = {
        'handle': MemberSpec_('handle', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'gender': MemberSpec_('gender', 'gender', 0),
        'name': MemberSpec_('name', 'name', 1),
        'eventref': MemberSpec_('eventref', 'eventref', 1),
        'lds_ord': MemberSpec_('lds_ord', 'lds_ord', 1),
        'objref': MemberSpec_('objref', 'objref', 1),
        'address': MemberSpec_('address', 'address', 1),
        'attribute': MemberSpec_('attribute', 'attribute', 1),
        'url': MemberSpec_('url', 'url', 1),
        'childof': MemberSpec_('childof', 'childof', 1),
        'parentin': MemberSpec_('parentin', 'parentin', 1),
        'personref': MemberSpec_('personref', 'personref', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, handle=None, id=None, change=None, priv=None, gender=None, name=None, eventref=None, lds_ord=None, objref=None, address=None, attribute=None, url=None, childof=None, parentin=None, personref=None, noteref=None, citationref=None, tagref=None):
        self.original_tagname_ = None
        self.handle = _cast(None, handle)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.gender = gender
        if name is None:
            self.name = []
        else:
            self.name = name
        if eventref is None:
            self.eventref = []
        else:
            self.eventref = eventref
        if lds_ord is None:
            self.lds_ord = []
        else:
            self.lds_ord = lds_ord
        if objref is None:
            self.objref = []
        else:
            self.objref = objref
        if address is None:
            self.address = []
        else:
            self.address = address
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if url is None:
            self.url = []
        else:
            self.url = url
        if childof is None:
            self.childof = []
        else:
            self.childof = childof
        if parentin is None:
            self.parentin = []
        else:
            self.parentin = parentin
        if personref is None:
            self.personref = []
        else:
            self.personref = personref
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if person.subclass:
            return person.subclass(*args_, **kwargs_)
        else:
            return person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gender(self): return self.gender
    def set_gender(self, gender): self.gender = gender
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    def get_eventref(self): return self.eventref
    def set_eventref(self, eventref): self.eventref = eventref
    def add_eventref(self, value): self.eventref.append(value)
    def insert_eventref_at(self, index, value): self.eventref.insert(index, value)
    def replace_eventref_at(self, index, value): self.eventref[index] = value
    def get_lds_ord(self): return self.lds_ord
    def set_lds_ord(self, lds_ord): self.lds_ord = lds_ord
    def add_lds_ord(self, value): self.lds_ord.append(value)
    def insert_lds_ord_at(self, index, value): self.lds_ord.insert(index, value)
    def replace_lds_ord_at(self, index, value): self.lds_ord[index] = value
    def get_objref(self): return self.objref
    def set_objref(self, objref): self.objref = objref
    def add_objref(self, value): self.objref.append(value)
    def insert_objref_at(self, index, value): self.objref.insert(index, value)
    def replace_objref_at(self, index, value): self.objref[index] = value
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def add_address(self, value): self.address.append(value)
    def insert_address_at(self, index, value): self.address.insert(index, value)
    def replace_address_at(self, index, value): self.address[index] = value
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def add_url(self, value): self.url.append(value)
    def insert_url_at(self, index, value): self.url.insert(index, value)
    def replace_url_at(self, index, value): self.url[index] = value
    def get_childof(self): return self.childof
    def set_childof(self, childof): self.childof = childof
    def add_childof(self, value): self.childof.append(value)
    def insert_childof_at(self, index, value): self.childof.insert(index, value)
    def replace_childof_at(self, index, value): self.childof[index] = value
    def get_parentin(self): return self.parentin
    def set_parentin(self, parentin): self.parentin = parentin
    def add_parentin(self, value): self.parentin.append(value)
    def insert_parentin_at(self, index, value): self.parentin.insert(index, value)
    def replace_parentin_at(self, index, value): self.parentin[index] = value
    def get_personref(self): return self.personref
    def set_personref(self, personref): self.personref = personref
    def add_personref(self, value): self.personref.append(value)
    def insert_personref_at(self, index, value): self.personref.insert(index, value)
    def replace_personref_at(self, index, value): self.personref[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.gender is not None or
            self.name or
            self.eventref or
            self.lds_ord or
            self.objref or
            self.address or
            self.attribute or
            self.url or
            self.childof or
            self.parentin or
            self.personref or
            self.noteref or
            self.citationref or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='person', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='person')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='person'):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.gender is not None:
            self.gender.export(outfile, level, namespace_='gramps:', name_='gender', pretty_print=pretty_print)
        for name_ in self.name:
            name_.export(outfile, level, namespace_='gramps:', name_='name', pretty_print=pretty_print)
        for eventref_ in self.eventref:
            eventref_.export(outfile, level, namespace_='gramps:', name_='eventref', pretty_print=pretty_print)
        for lds_ord_ in self.lds_ord:
            lds_ord_.export(outfile, level, namespace_='gramps:', name_='lds_ord', pretty_print=pretty_print)
        for objref_ in self.objref:
            objref_.export(outfile, level, namespace_='gramps:', name_='objref', pretty_print=pretty_print)
        for address_ in self.address:
            address_.export(outfile, level, namespace_='gramps:', name_='address', pretty_print=pretty_print)
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_='gramps:', name_='attribute', pretty_print=pretty_print)
        for url_ in self.url:
            url_.export(outfile, level, namespace_='gramps:', name_='url', pretty_print=pretty_print)
        for childof_ in self.childof:
            childof_.export(outfile, level, namespace_='gramps:', name_='childof', pretty_print=pretty_print)
        for parentin_ in self.parentin:
            parentin_.export(outfile, level, namespace_='gramps:', name_='parentin', pretty_print=pretty_print)
        for personref_ in self.personref:
            personref_.export(outfile, level, namespace_='gramps:', name_='personref', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='person'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.gender is not None:
            showIndent(outfile, level)
            outfile.write('gender=model_.gender(\n')
            self.gender.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('name=[\n')
        level += 1
        for name_ in self.name:
            showIndent(outfile, level)
            outfile.write('model_.name(\n')
            name_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('eventref=[\n')
        level += 1
        for eventref_ in self.eventref:
            showIndent(outfile, level)
            outfile.write('model_.eventref(\n')
            eventref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('lds_ord=[\n')
        level += 1
        for lds_ord_ in self.lds_ord:
            showIndent(outfile, level)
            outfile.write('model_.lds_ord(\n')
            lds_ord_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('objref=[\n')
        level += 1
        for objref_ in self.objref:
            showIndent(outfile, level)
            outfile.write('model_.objref(\n')
            objref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('address=[\n')
        level += 1
        for address_ in self.address:
            showIndent(outfile, level)
            outfile.write('model_.address(\n')
            address_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('url=[\n')
        level += 1
        for url_ in self.url:
            showIndent(outfile, level)
            outfile.write('model_.url(\n')
            url_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('childof=[\n')
        level += 1
        for childof_ in self.childof:
            showIndent(outfile, level)
            outfile.write('model_.childof(\n')
            childof_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('parentin=[\n')
        level += 1
        for parentin_ in self.parentin:
            showIndent(outfile, level)
            outfile.write('model_.parentin(\n')
            parentin_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('personref=[\n')
        level += 1
        for personref_ in self.personref:
            showIndent(outfile, level)
            outfile.write('model_.personref(\n')
            personref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gender':
            obj_ = gender.factory()
            obj_.build(child_)
            self.gender = obj_
            obj_.original_tagname_ = 'gender'
        elif nodeName_ == 'name':
            obj_ = name.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'eventref':
            obj_ = eventref.factory()
            obj_.build(child_)
            self.eventref.append(obj_)
            obj_.original_tagname_ = 'eventref'
        elif nodeName_ == 'lds_ord':
            obj_ = lds_ord.factory()
            obj_.build(child_)
            self.lds_ord.append(obj_)
            obj_.original_tagname_ = 'lds_ord'
        elif nodeName_ == 'objref':
            obj_ = objref.factory()
            obj_.build(child_)
            self.objref.append(obj_)
            obj_.original_tagname_ = 'objref'
        elif nodeName_ == 'address':
            obj_ = address.factory()
            obj_.build(child_)
            self.address.append(obj_)
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
        elif nodeName_ == 'url':
            obj_ = url.factory()
            obj_.build(child_)
            self.url.append(obj_)
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'childof':
            obj_ = childof.factory()
            obj_.build(child_)
            self.childof.append(obj_)
            obj_.original_tagname_ = 'childof'
        elif nodeName_ == 'parentin':
            obj_ = parentin.factory()
            obj_.build(child_)
            self.parentin.append(obj_)
            obj_.original_tagname_ = 'parentin'
        elif nodeName_ == 'personref':
            obj_ = personref.factory()
            obj_.build(child_)
            self.personref.append(obj_)
            obj_.original_tagname_ = 'personref'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class person


class gender(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if gender.subclass:
            return gender.subclass(*args_, **kwargs_)
        else:
            return gender(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='gender', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gender')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='gender'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='gender', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='gender'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class gender


class name(GeneratedsSuper):
    member_data_items_ = {
        'sort': MemberSpec_('sort', 'string', 0),
        'alt': MemberSpec_('alt', 'string', 0),
        'type': MemberSpec_('type', 'string', 0),
        'display': MemberSpec_('display', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'first': MemberSpec_('first', 'first', 0),
        'call': MemberSpec_('call', 'call', 0),
        'surname': MemberSpec_('surname', 'surname', 1),
        'suffix': MemberSpec_('suffix', 'suffix', 0),
        'title': MemberSpec_('title', 'title', 0),
        'nick': MemberSpec_('nick', 'nick', 0),
        'familynick': MemberSpec_('familynick', 'familynick', 0),
        'group': MemberSpec_('group', 'group', 0),
        'daterange': MemberSpec_('daterange', 'daterange', 0),
        'datespan': MemberSpec_('datespan', 'datespan', 0),
        'dateval': MemberSpec_('dateval', 'dateval', 0),
        'datestr': MemberSpec_('datestr', 'datestr', 0),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, sort=None, alt=None, type_=None, display=None, priv=None, first=None, call=None, surname=None, suffix=None, title=None, nick=None, familynick=None, group=None, daterange=None, datespan=None, dateval=None, datestr=None, noteref=None, citationref=None):
        self.original_tagname_ = None
        self.sort = _cast(None, sort)
        self.alt = _cast(None, alt)
        self.type_ = _cast(None, type_)
        self.display = _cast(None, display)
        self.priv = _cast(None, priv)
        self.first = first
        self.call = call
        if surname is None:
            self.surname = []
        else:
            self.surname = surname
        self.suffix = suffix
        self.title = title
        self.nick = nick
        self.familynick = familynick
        self.group = group
        self.daterange = daterange
        self.datespan = datespan
        self.dateval = dateval
        self.datestr = datestr
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
    def factory(*args_, **kwargs_):
        if name.subclass:
            return name.subclass(*args_, **kwargs_)
        else:
            return name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_first(self): return self.first
    def set_first(self, first): self.first = first
    def get_call(self): return self.call
    def set_call(self, call): self.call = call
    def get_surname(self): return self.surname
    def set_surname(self, surname): self.surname = surname
    def add_surname(self, value): self.surname.append(value)
    def insert_surname_at(self, index, value): self.surname.insert(index, value)
    def replace_surname_at(self, index, value): self.surname[index] = value
    def get_suffix(self): return self.suffix
    def set_suffix(self, suffix): self.suffix = suffix
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_nick(self): return self.nick
    def set_nick(self, nick): self.nick = nick
    def get_familynick(self): return self.familynick
    def set_familynick(self, familynick): self.familynick = familynick
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_daterange(self): return self.daterange
    def set_daterange(self, daterange): self.daterange = daterange
    def get_datespan(self): return self.datespan
    def set_datespan(self, datespan): self.datespan = datespan
    def get_dateval(self): return self.dateval
    def set_dateval(self, dateval): self.dateval = dateval
    def get_datestr(self): return self.datestr
    def set_datestr(self, datestr): self.datestr = datestr
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_sort(self): return self.sort
    def set_sort(self, sort): self.sort = sort
    def get_alt(self): return self.alt
    def set_alt(self, alt): self.alt = alt
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_display(self): return self.display
    def set_display(self, display): self.display = display
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.first is not None or
            self.call is not None or
            self.surname or
            self.suffix is not None or
            self.title is not None or
            self.nick is not None or
            self.familynick is not None or
            self.group is not None or
            self.daterange is not None or
            self.datespan is not None or
            self.dateval is not None or
            self.datestr is not None or
            self.noteref or
            self.citationref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='name', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='name', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='name'):
        if self.sort is not None and 'sort' not in already_processed:
            already_processed.add('sort')
            outfile.write(' sort=%s' % (self.gds_format_string(quote_attrib(self.sort).encode(ExternalEncoding), input_name='sort'), ))
        if self.alt is not None and 'alt' not in already_processed:
            already_processed.add('alt')
            outfile.write(' alt=%s' % (self.gds_format_string(quote_attrib(self.alt).encode(ExternalEncoding), input_name='alt'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.display is not None and 'display' not in already_processed:
            already_processed.add('display')
            outfile.write(' display=%s' % (self.gds_format_string(quote_attrib(self.display).encode(ExternalEncoding), input_name='display'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='name', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.first is not None:
            self.first.export(outfile, level, namespace_='gramps:', name_='first', pretty_print=pretty_print)
        if self.call is not None:
            self.call.export(outfile, level, namespace_='gramps:', name_='call', pretty_print=pretty_print)
        for surname_ in self.surname:
            surname_.export(outfile, level, namespace_='gramps:', name_='surname', pretty_print=pretty_print)
        if self.suffix is not None:
            self.suffix.export(outfile, level, namespace_='gramps:', name_='suffix', pretty_print=pretty_print)
        if self.title is not None:
            self.title.export(outfile, level, namespace_='gramps:', name_='title', pretty_print=pretty_print)
        if self.nick is not None:
            self.nick.export(outfile, level, namespace_='gramps:', name_='nick', pretty_print=pretty_print)
        if self.familynick is not None:
            self.familynick.export(outfile, level, namespace_='gramps:', name_='familynick', pretty_print=pretty_print)
        if self.group is not None:
            self.group.export(outfile, level, namespace_='gramps:', name_='group', pretty_print=pretty_print)
        if self.daterange is not None:
            self.daterange.export(outfile, level, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
        if self.datespan is not None:
            self.datespan.export(outfile, level, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
        if self.dateval is not None:
            self.dateval.export(outfile, level, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
        if self.datestr is not None:
            self.datestr.export(outfile, level, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='name'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sort is not None and 'sort' not in already_processed:
            already_processed.add('sort')
            showIndent(outfile, level)
            outfile.write('sort="%s",\n' % (self.sort,))
        if self.alt is not None and 'alt' not in already_processed:
            already_processed.add('alt')
            showIndent(outfile, level)
            outfile.write('alt="%s",\n' % (self.alt,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.display is not None and 'display' not in already_processed:
            already_processed.add('display')
            showIndent(outfile, level)
            outfile.write('display="%s",\n' % (self.display,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.first is not None:
            showIndent(outfile, level)
            outfile.write('first=model_.first(\n')
            self.first.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.call is not None:
            showIndent(outfile, level)
            outfile.write('call=model_.call(\n')
            self.call.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('surname=[\n')
        level += 1
        for surname_ in self.surname:
            showIndent(outfile, level)
            outfile.write('model_.surname(\n')
            surname_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.suffix is not None:
            showIndent(outfile, level)
            outfile.write('suffix=model_.suffix(\n')
            self.suffix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.title(\n')
            self.title.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nick is not None:
            showIndent(outfile, level)
            outfile.write('nick=model_.nick(\n')
            self.nick.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.familynick is not None:
            showIndent(outfile, level)
            outfile.write('familynick=model_.familynick(\n')
            self.familynick.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=model_.group(\n')
            self.group.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.daterange is not None:
            showIndent(outfile, level)
            outfile.write('daterange=model_.daterange(\n')
            self.daterange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datespan is not None:
            showIndent(outfile, level)
            outfile.write('datespan=model_.datespan(\n')
            self.datespan.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateval is not None:
            showIndent(outfile, level)
            outfile.write('dateval=model_.dateval(\n')
            self.dateval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datestr is not None:
            showIndent(outfile, level)
            outfile.write('datestr=model_.datestr(\n')
            self.datestr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sort', node)
        if value is not None and 'sort' not in already_processed:
            already_processed.add('sort')
            self.sort = value
        value = find_attr_value_('alt', node)
        if value is not None and 'alt' not in already_processed:
            already_processed.add('alt')
            self.alt = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('display', node)
        if value is not None and 'display' not in already_processed:
            already_processed.add('display')
            self.display = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'first':
            obj_ = first.factory()
            obj_.build(child_)
            self.first = obj_
            obj_.original_tagname_ = 'first'
        elif nodeName_ == 'call':
            obj_ = call.factory()
            obj_.build(child_)
            self.call = obj_
            obj_.original_tagname_ = 'call'
        elif nodeName_ == 'surname':
            obj_ = surname.factory()
            obj_.build(child_)
            self.surname.append(obj_)
            obj_.original_tagname_ = 'surname'
        elif nodeName_ == 'suffix':
            obj_ = suffix.factory()
            obj_.build(child_)
            self.suffix = obj_
            obj_.original_tagname_ = 'suffix'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'nick':
            obj_ = nick.factory()
            obj_.build(child_)
            self.nick = obj_
            obj_.original_tagname_ = 'nick'
        elif nodeName_ == 'familynick':
            obj_ = familynick.factory()
            obj_.build(child_)
            self.familynick = obj_
            obj_.original_tagname_ = 'familynick'
        elif nodeName_ == 'group':
            obj_ = group.factory()
            obj_.build(child_)
            self.group = obj_
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'daterange':
            obj_ = daterange.factory()
            obj_.build(child_)
            self.daterange = obj_
            obj_.original_tagname_ = 'daterange'
        elif nodeName_ == 'datespan':
            obj_ = datespan.factory()
            obj_.build(child_)
            self.datespan = obj_
            obj_.original_tagname_ = 'datespan'
        elif nodeName_ == 'dateval':
            obj_ = dateval.factory()
            obj_.build(child_)
            self.dateval = obj_
            obj_.original_tagname_ = 'dateval'
        elif nodeName_ == 'datestr':
            obj_ = datestr.factory()
            obj_.build(child_)
            self.datestr = obj_
            obj_.original_tagname_ = 'datestr'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
# end class name


class first(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if first.subclass:
            return first.subclass(*args_, **kwargs_)
        else:
            return first(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='first', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='first')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='first'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='first', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='first'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class first


class call(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if call.subclass:
            return call.subclass(*args_, **kwargs_)
        else:
            return call(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='call', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='call')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='call'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='call', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='call'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class call


class suffix(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if suffix.subclass:
            return suffix.subclass(*args_, **kwargs_)
        else:
            return suffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='suffix', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='suffix')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='suffix'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='suffix', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='suffix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class suffix


class title(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if title.subclass:
            return title.subclass(*args_, **kwargs_)
        else:
            return title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='title', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='title')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='title'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='title', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='title'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class title


class nick(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nick.subclass:
            return nick.subclass(*args_, **kwargs_)
        else:
            return nick(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='nick', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nick')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='nick'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='nick', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='nick'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class nick


class familynick(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if familynick.subclass:
            return familynick.subclass(*args_, **kwargs_)
        else:
            return familynick(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='familynick', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='familynick')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='familynick'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='familynick', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='familynick'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class familynick


class group(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if group.subclass:
            return group.subclass(*args_, **kwargs_)
        else:
            return group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='group', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='group')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='group'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='group', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='group'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class group


class surname(GeneratedsSuper):
    member_data_items_ = {
        'connector': MemberSpec_('connector', 'string', 0),
        'prefix': MemberSpec_('prefix', 'string', 0),
        'prim': MemberSpec_('prim', 'string', 0),
        'derivation': MemberSpec_('derivation', 'string', 0),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, connector=None, prefix=None, prim=None, derivation=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.connector = _cast(None, connector)
        self.prefix = _cast(None, prefix)
        self.prim = _cast(None, prim)
        self.derivation = _cast(None, derivation)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if surname.subclass:
            return surname.subclass(*args_, **kwargs_)
        else:
            return surname(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connector(self): return self.connector
    def set_connector(self, connector): self.connector = connector
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_prim(self): return self.prim
    def set_prim(self, prim): self.prim = prim
    def get_derivation(self): return self.derivation
    def set_derivation(self, derivation): self.derivation = derivation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='surname', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='surname')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='surname'):
        if self.connector is not None and 'connector' not in already_processed:
            already_processed.add('connector')
            outfile.write(' connector=%s' % (self.gds_format_string(quote_attrib(self.connector).encode(ExternalEncoding), input_name='connector'), ))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (self.gds_format_string(quote_attrib(self.prefix).encode(ExternalEncoding), input_name='prefix'), ))
        if self.prim is not None and 'prim' not in already_processed:
            already_processed.add('prim')
            outfile.write(' prim=%s' % (self.gds_format_string(quote_attrib(self.prim).encode(ExternalEncoding), input_name='prim'), ))
        if self.derivation is not None and 'derivation' not in already_processed:
            already_processed.add('derivation')
            outfile.write(' derivation=%s' % (self.gds_format_string(quote_attrib(self.derivation).encode(ExternalEncoding), input_name='derivation'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='surname', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='surname'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.connector is not None and 'connector' not in already_processed:
            already_processed.add('connector')
            showIndent(outfile, level)
            outfile.write('connector="%s",\n' % (self.connector,))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            showIndent(outfile, level)
            outfile.write('prefix="%s",\n' % (self.prefix,))
        if self.prim is not None and 'prim' not in already_processed:
            already_processed.add('prim')
            showIndent(outfile, level)
            outfile.write('prim="%s",\n' % (self.prim,))
        if self.derivation is not None and 'derivation' not in already_processed:
            already_processed.add('derivation')
            showIndent(outfile, level)
            outfile.write('derivation="%s",\n' % (self.derivation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('connector', node)
        if value is not None and 'connector' not in already_processed:
            already_processed.add('connector')
            self.connector = value
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
        value = find_attr_value_('prim', node)
        if value is not None and 'prim' not in already_processed:
            already_processed.add('prim')
            self.prim = value
        value = find_attr_value_('derivation', node)
        if value is not None and 'derivation' not in already_processed:
            already_processed.add('derivation')
            self.derivation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class surname


class childof(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if childof.subclass:
            return childof.subclass(*args_, **kwargs_)
        else:
            return childof(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='childof', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childof')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='childof', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='childof'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='childof', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='childof'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class childof


class parentin(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if parentin.subclass:
            return parentin.subclass(*args_, **kwargs_)
        else:
            return parentin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='parentin', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parentin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='parentin', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='parentin'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='parentin', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='parentin'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class parentin


class personref(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
        'rel': MemberSpec_('rel', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None, rel=None, priv=None, citationref=None, noteref=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
        self.rel = _cast(None, rel)
        self.priv = _cast(None, priv)
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
    def factory(*args_, **kwargs_):
        if personref.subclass:
            return personref.subclass(*args_, **kwargs_)
        else:
            return personref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.citationref or
            self.noteref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='personref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='personref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='personref', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='personref'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_format_string(quote_attrib(self.rel).encode(ExternalEncoding), input_name='rel'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='personref', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='personref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            showIndent(outfile, level)
            outfile.write('rel="%s",\n' % (self.rel,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
# end class personref


class address(GeneratedsSuper):
    member_data_items_ = {
        'priv': MemberSpec_('priv', 'string', 0),
        'daterange': MemberSpec_('daterange', 'daterange', 0),
        'datespan': MemberSpec_('datespan', 'datespan', 0),
        'dateval': MemberSpec_('dateval', 'dateval', 0),
        'datestr': MemberSpec_('datestr', 'datestr', 0),
        'street': MemberSpec_('street', 'street', 0),
        'locality': MemberSpec_('locality', 'locality', 0),
        'city': MemberSpec_('city', 'city', 0),
        'county': MemberSpec_('county', 'county', 0),
        'state': MemberSpec_('state', 'state', 0),
        'country': MemberSpec_('country', 'country', 0),
        'postal': MemberSpec_('postal', 'postal', 0),
        'phone': MemberSpec_('phone', 'phone', 0),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, priv=None, daterange=None, datespan=None, dateval=None, datestr=None, street=None, locality=None, city=None, county=None, state=None, country=None, postal=None, phone=None, noteref=None, citationref=None):
        self.original_tagname_ = None
        self.priv = _cast(None, priv)
        self.daterange = daterange
        self.datespan = datespan
        self.dateval = dateval
        self.datestr = datestr
        self.street = street
        self.locality = locality
        self.city = city
        self.county = county
        self.state = state
        self.country = country
        self.postal = postal
        self.phone = phone
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
    def factory(*args_, **kwargs_):
        if address.subclass:
            return address.subclass(*args_, **kwargs_)
        else:
            return address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_daterange(self): return self.daterange
    def set_daterange(self, daterange): self.daterange = daterange
    def get_datespan(self): return self.datespan
    def set_datespan(self, datespan): self.datespan = datespan
    def get_dateval(self): return self.dateval
    def set_dateval(self, dateval): self.dateval = dateval
    def get_datestr(self): return self.datestr
    def set_datestr(self, datestr): self.datestr = datestr
    def get_street(self): return self.street
    def set_street(self, street): self.street = street
    def get_locality(self): return self.locality
    def set_locality(self, locality): self.locality = locality
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_county(self): return self.county
    def set_county(self, county): self.county = county
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_postal(self): return self.postal
    def set_postal(self, postal): self.postal = postal
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.daterange is not None or
            self.datespan is not None or
            self.dateval is not None or
            self.datestr is not None or
            self.street is not None or
            self.locality is not None or
            self.city is not None or
            self.county is not None or
            self.state is not None or
            self.country is not None or
            self.postal is not None or
            self.phone is not None or
            self.noteref or
            self.citationref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='address', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='address'):
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.daterange is not None:
            self.daterange.export(outfile, level, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
        if self.datespan is not None:
            self.datespan.export(outfile, level, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
        if self.dateval is not None:
            self.dateval.export(outfile, level, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
        if self.datestr is not None:
            self.datestr.export(outfile, level, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
        if self.street is not None:
            self.street.export(outfile, level, namespace_='gramps:', name_='street', pretty_print=pretty_print)
        if self.locality is not None:
            self.locality.export(outfile, level, namespace_='gramps:', name_='locality', pretty_print=pretty_print)
        if self.city is not None:
            self.city.export(outfile, level, namespace_='gramps:', name_='city', pretty_print=pretty_print)
        if self.county is not None:
            self.county.export(outfile, level, namespace_='gramps:', name_='county', pretty_print=pretty_print)
        if self.state is not None:
            self.state.export(outfile, level, namespace_='gramps:', name_='state', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_='gramps:', name_='country', pretty_print=pretty_print)
        if self.postal is not None:
            self.postal.export(outfile, level, namespace_='gramps:', name_='postal', pretty_print=pretty_print)
        if self.phone is not None:
            self.phone.export(outfile, level, namespace_='gramps:', name_='phone', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='address'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.daterange is not None:
            showIndent(outfile, level)
            outfile.write('daterange=model_.daterange(\n')
            self.daterange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datespan is not None:
            showIndent(outfile, level)
            outfile.write('datespan=model_.datespan(\n')
            self.datespan.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateval is not None:
            showIndent(outfile, level)
            outfile.write('dateval=model_.dateval(\n')
            self.dateval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datestr is not None:
            showIndent(outfile, level)
            outfile.write('datestr=model_.datestr(\n')
            self.datestr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.street is not None:
            showIndent(outfile, level)
            outfile.write('street=model_.street(\n')
            self.street.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.locality is not None:
            showIndent(outfile, level)
            outfile.write('locality=model_.locality(\n')
            self.locality.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.city is not None:
            showIndent(outfile, level)
            outfile.write('city=model_.city(\n')
            self.city.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.county is not None:
            showIndent(outfile, level)
            outfile.write('county=model_.county(\n')
            self.county.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state=model_.state(\n')
            self.state.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=model_.country(\n')
            self.country.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.postal is not None:
            showIndent(outfile, level)
            outfile.write('postal=model_.postal(\n')
            self.postal.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.phone is not None:
            showIndent(outfile, level)
            outfile.write('phone=model_.phone(\n')
            self.phone.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'daterange':
            obj_ = daterange.factory()
            obj_.build(child_)
            self.daterange = obj_
            obj_.original_tagname_ = 'daterange'
        elif nodeName_ == 'datespan':
            obj_ = datespan.factory()
            obj_.build(child_)
            self.datespan = obj_
            obj_.original_tagname_ = 'datespan'
        elif nodeName_ == 'dateval':
            obj_ = dateval.factory()
            obj_.build(child_)
            self.dateval = obj_
            obj_.original_tagname_ = 'dateval'
        elif nodeName_ == 'datestr':
            obj_ = datestr.factory()
            obj_.build(child_)
            self.datestr = obj_
            obj_.original_tagname_ = 'datestr'
        elif nodeName_ == 'street':
            obj_ = street.factory()
            obj_.build(child_)
            self.street = obj_
            obj_.original_tagname_ = 'street'
        elif nodeName_ == 'locality':
            obj_ = locality.factory()
            obj_.build(child_)
            self.locality = obj_
            obj_.original_tagname_ = 'locality'
        elif nodeName_ == 'city':
            obj_ = city.factory()
            obj_.build(child_)
            self.city = obj_
            obj_.original_tagname_ = 'city'
        elif nodeName_ == 'county':
            obj_ = county.factory()
            obj_.build(child_)
            self.county = obj_
            obj_.original_tagname_ = 'county'
        elif nodeName_ == 'state':
            obj_ = state.factory()
            obj_.build(child_)
            self.state = obj_
            obj_.original_tagname_ = 'state'
        elif nodeName_ == 'country':
            obj_ = country.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'postal':
            obj_ = postal.factory()
            obj_.build(child_)
            self.postal = obj_
            obj_.original_tagname_ = 'postal'
        elif nodeName_ == 'phone':
            obj_ = phone.factory()
            obj_.build(child_)
            self.phone = obj_
            obj_.original_tagname_ = 'phone'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
# end class address


class street(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if street.subclass:
            return street.subclass(*args_, **kwargs_)
        else:
            return street(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='street', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='street')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='street'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='street', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='street'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class street


class locality(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if locality.subclass:
            return locality.subclass(*args_, **kwargs_)
        else:
            return locality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='locality', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='locality')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='locality'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='locality', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='locality'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class locality


class city(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if city.subclass:
            return city.subclass(*args_, **kwargs_)
        else:
            return city(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='city', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='city')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='city'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='city', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='city'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class city


class county(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if county.subclass:
            return county.subclass(*args_, **kwargs_)
        else:
            return county(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='county', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='county')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='county'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='county', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='county'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class county


class state(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if state.subclass:
            return state.subclass(*args_, **kwargs_)
        else:
            return state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='state', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='state'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='state', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='state'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class state


class country(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if country.subclass:
            return country.subclass(*args_, **kwargs_)
        else:
            return country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='country', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='country')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='country'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='country', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='country'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class country


class postal(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if postal.subclass:
            return postal.subclass(*args_, **kwargs_)
        else:
            return postal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='postal', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='postal')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='postal'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='postal', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='postal'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class postal


class phone(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if phone.subclass:
            return phone.subclass(*args_, **kwargs_)
        else:
            return phone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='phone', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='phone')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='phone'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='phone', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='phone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class phone


class families(GeneratedsSuper):
    member_data_items_ = {
        'family': MemberSpec_('family', 'family', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, family=None):
        self.original_tagname_ = None
        if family is None:
            self.family = []
        else:
            self.family = family
    def factory(*args_, **kwargs_):
        if families.subclass:
            return families.subclass(*args_, **kwargs_)
        else:
            return families(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def add_family(self, value): self.family.append(value)
    def insert_family_at(self, index, value): self.family.insert(index, value)
    def replace_family_at(self, index, value): self.family[index] = value
    def hasContent_(self):
        if (
            self.family
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='families', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='families')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='families', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='families'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='families', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for family_ in self.family:
            family_.export(outfile, level, namespace_='gramps:', name_='family', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='families'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('family=[\n')
        level += 1
        for family_ in self.family:
            showIndent(outfile, level)
            outfile.write('model_.family(\n')
            family_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'family':
            obj_ = family.factory()
            obj_.build(child_)
            self.family.append(obj_)
            obj_.original_tagname_ = 'family'
# end class families


class family(GeneratedsSuper):
    member_data_items_ = {
        'handle': MemberSpec_('handle', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'rel': MemberSpec_('rel', 'rel', 0),
        'father': MemberSpec_('father', 'father', 0),
        'mother': MemberSpec_('mother', 'mother', 0),
        'eventref': MemberSpec_('eventref', 'eventref', 1),
        'lds_ord': MemberSpec_('lds_ord', 'lds_ord', 1),
        'objref': MemberSpec_('objref', 'objref', 1),
        'childref': MemberSpec_('childref', 'childref', 1),
        'attribute': MemberSpec_('attribute', 'attribute', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, handle=None, id=None, change=None, priv=None, rel=None, father=None, mother=None, eventref=None, lds_ord=None, objref=None, childref=None, attribute=None, noteref=None, citationref=None, tagref=None):
        self.original_tagname_ = None
        self.handle = _cast(None, handle)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.rel = rel
        self.father = father
        self.mother = mother
        if eventref is None:
            self.eventref = []
        else:
            self.eventref = eventref
        if lds_ord is None:
            self.lds_ord = []
        else:
            self.lds_ord = lds_ord
        if objref is None:
            self.objref = []
        else:
            self.objref = objref
        if childref is None:
            self.childref = []
        else:
            self.childref = childref
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if family.subclass:
            return family.subclass(*args_, **kwargs_)
        else:
            return family(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def get_father(self): return self.father
    def set_father(self, father): self.father = father
    def get_mother(self): return self.mother
    def set_mother(self, mother): self.mother = mother
    def get_eventref(self): return self.eventref
    def set_eventref(self, eventref): self.eventref = eventref
    def add_eventref(self, value): self.eventref.append(value)
    def insert_eventref_at(self, index, value): self.eventref.insert(index, value)
    def replace_eventref_at(self, index, value): self.eventref[index] = value
    def get_lds_ord(self): return self.lds_ord
    def set_lds_ord(self, lds_ord): self.lds_ord = lds_ord
    def add_lds_ord(self, value): self.lds_ord.append(value)
    def insert_lds_ord_at(self, index, value): self.lds_ord.insert(index, value)
    def replace_lds_ord_at(self, index, value): self.lds_ord[index] = value
    def get_objref(self): return self.objref
    def set_objref(self, objref): self.objref = objref
    def add_objref(self, value): self.objref.append(value)
    def insert_objref_at(self, index, value): self.objref.insert(index, value)
    def replace_objref_at(self, index, value): self.objref[index] = value
    def get_childref(self): return self.childref
    def set_childref(self, childref): self.childref = childref
    def add_childref(self, value): self.childref.append(value)
    def insert_childref_at(self, index, value): self.childref.insert(index, value)
    def replace_childref_at(self, index, value): self.childref[index] = value
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.rel is not None or
            self.father is not None or
            self.mother is not None or
            self.eventref or
            self.lds_ord or
            self.objref or
            self.childref or
            self.attribute or
            self.noteref or
            self.citationref or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='family', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='family')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='family', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='family'):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='family', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rel is not None:
            self.rel.export(outfile, level, namespace_='gramps:', name_='rel', pretty_print=pretty_print)
        if self.father is not None:
            self.father.export(outfile, level, namespace_='gramps:', name_='father', pretty_print=pretty_print)
        if self.mother is not None:
            self.mother.export(outfile, level, namespace_='gramps:', name_='mother', pretty_print=pretty_print)
        for eventref_ in self.eventref:
            eventref_.export(outfile, level, namespace_='gramps:', name_='eventref', pretty_print=pretty_print)
        for lds_ord_ in self.lds_ord:
            lds_ord_.export(outfile, level, namespace_='gramps:', name_='lds_ord', pretty_print=pretty_print)
        for objref_ in self.objref:
            objref_.export(outfile, level, namespace_='gramps:', name_='objref', pretty_print=pretty_print)
        for childref_ in self.childref:
            childref_.export(outfile, level, namespace_='gramps:', name_='childref', pretty_print=pretty_print)
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_='gramps:', name_='attribute', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='family'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rel is not None:
            showIndent(outfile, level)
            outfile.write('rel=model_.rel(\n')
            self.rel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.father is not None:
            showIndent(outfile, level)
            outfile.write('father=model_.father(\n')
            self.father.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mother is not None:
            showIndent(outfile, level)
            outfile.write('mother=model_.mother(\n')
            self.mother.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('eventref=[\n')
        level += 1
        for eventref_ in self.eventref:
            showIndent(outfile, level)
            outfile.write('model_.eventref(\n')
            eventref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('lds_ord=[\n')
        level += 1
        for lds_ord_ in self.lds_ord:
            showIndent(outfile, level)
            outfile.write('model_.lds_ord(\n')
            lds_ord_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('objref=[\n')
        level += 1
        for objref_ in self.objref:
            showIndent(outfile, level)
            outfile.write('model_.objref(\n')
            objref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('childref=[\n')
        level += 1
        for childref_ in self.childref:
            showIndent(outfile, level)
            outfile.write('model_.childref(\n')
            childref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rel':
            obj_ = rel.factory()
            obj_.build(child_)
            self.rel = obj_
            obj_.original_tagname_ = 'rel'
        elif nodeName_ == 'father':
            obj_ = father.factory()
            obj_.build(child_)
            self.father = obj_
            obj_.original_tagname_ = 'father'
        elif nodeName_ == 'mother':
            obj_ = mother.factory()
            obj_.build(child_)
            self.mother = obj_
            obj_.original_tagname_ = 'mother'
        elif nodeName_ == 'eventref':
            obj_ = eventref.factory()
            obj_.build(child_)
            self.eventref.append(obj_)
            obj_.original_tagname_ = 'eventref'
        elif nodeName_ == 'lds_ord':
            obj_ = lds_ord.factory()
            obj_.build(child_)
            self.lds_ord.append(obj_)
            obj_.original_tagname_ = 'lds_ord'
        elif nodeName_ == 'objref':
            obj_ = objref.factory()
            obj_.build(child_)
            self.objref.append(obj_)
            obj_.original_tagname_ = 'objref'
        elif nodeName_ == 'childref':
            obj_ = childref.factory()
            obj_.build(child_)
            self.childref.append(obj_)
            obj_.original_tagname_ = 'childref'
        elif nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class family


class father(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if father.subclass:
            return father.subclass(*args_, **kwargs_)
        else:
            return father(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='father', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='father')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='father', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='father'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='father', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='father'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class father


class mother(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if mother.subclass:
            return mother.subclass(*args_, **kwargs_)
        else:
            return mother(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='mother', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mother')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='mother', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='mother'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='mother', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mother'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mother


class childref(GeneratedsSuper):
    member_data_items_ = {
        'frel': MemberSpec_('frel', 'string', 0),
        'hlink': MemberSpec_('hlink', 'string', 0),
        'mrel': MemberSpec_('mrel', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, frel=None, hlink=None, mrel=None, priv=None, citationref=None, noteref=None):
        self.original_tagname_ = None
        self.frel = _cast(None, frel)
        self.hlink = _cast(None, hlink)
        self.mrel = _cast(None, mrel)
        self.priv = _cast(None, priv)
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
    def factory(*args_, **kwargs_):
        if childref.subclass:
            return childref.subclass(*args_, **kwargs_)
        else:
            return childref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_frel(self): return self.frel
    def set_frel(self, frel): self.frel = frel
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def get_mrel(self): return self.mrel
    def set_mrel(self, mrel): self.mrel = mrel
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.citationref or
            self.noteref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='childref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='childref', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='childref'):
        if self.frel is not None and 'frel' not in already_processed:
            already_processed.add('frel')
            outfile.write(' frel=%s' % (self.gds_format_string(quote_attrib(self.frel).encode(ExternalEncoding), input_name='frel'), ))
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
        if self.mrel is not None and 'mrel' not in already_processed:
            already_processed.add('mrel')
            outfile.write(' mrel=%s' % (self.gds_format_string(quote_attrib(self.mrel).encode(ExternalEncoding), input_name='mrel'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='childref', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='childref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.frel is not None and 'frel' not in already_processed:
            already_processed.add('frel')
            showIndent(outfile, level)
            outfile.write('frel="%s",\n' % (self.frel,))
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
        if self.mrel is not None and 'mrel' not in already_processed:
            already_processed.add('mrel')
            showIndent(outfile, level)
            outfile.write('mrel="%s",\n' % (self.mrel,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frel', node)
        if value is not None and 'frel' not in already_processed:
            already_processed.add('frel')
            self.frel = value
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
        value = find_attr_value_('mrel', node)
        if value is not None and 'mrel' not in already_processed:
            already_processed.add('mrel')
            self.mrel = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
# end class childref


class type_(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='type', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='type'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class type_


class rel(GeneratedsSuper):
    member_data_items_ = {
        'type': MemberSpec_('type', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if rel.subclass:
            return rel.subclass(*args_, **kwargs_)
        else:
            return rel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='rel', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='rel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='rel'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='rel', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rel


class events(GeneratedsSuper):
    member_data_items_ = {
        'event': MemberSpec_('event', 'event', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, event=None):
        self.original_tagname_ = None
        if event is None:
            self.event = []
        else:
            self.event = event
    def factory(*args_, **kwargs_):
        if events.subclass:
            return events.subclass(*args_, **kwargs_)
        else:
            return events(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def add_event(self, value): self.event.append(value)
    def insert_event_at(self, index, value): self.event.insert(index, value)
    def replace_event_at(self, index, value): self.event[index] = value
    def hasContent_(self):
        if (
            self.event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='events', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='events')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='events', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='events'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='events', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            event_.export(outfile, level, namespace_='gramps:', name_='event', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='events'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('event=[\n')
        level += 1
        for event_ in self.event:
            showIndent(outfile, level)
            outfile.write('model_.event(\n')
            event_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'event':
            obj_ = event.factory()
            obj_.build(child_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
# end class events


class event(GeneratedsSuper):
    member_data_items_ = {
        'handle': MemberSpec_('handle', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'type_': MemberSpec_('type_', 'type', 0),
        'daterange': MemberSpec_('daterange', 'daterange', 0),
        'datespan': MemberSpec_('datespan', 'datespan', 0),
        'dateval': MemberSpec_('dateval', 'dateval', 0),
        'datestr': MemberSpec_('datestr', 'datestr', 0),
        'place': MemberSpec_('place', 'place', 0),
        'cause': MemberSpec_('cause', 'cause', 0),
        'description': MemberSpec_('description', 'description', 0),
        'attribute': MemberSpec_('attribute', 'attribute', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'objref': MemberSpec_('objref', 'objref', 1),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, handle=None, id=None, change=None, priv=None, type_=None, daterange=None, datespan=None, dateval=None, datestr=None, place=None, cause=None, description=None, attribute=None, noteref=None, citationref=None, objref=None, tagref=None):
        self.original_tagname_ = None
        self.handle = _cast(None, handle)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.type_ = type_
        self.daterange = daterange
        self.datespan = datespan
        self.dateval = dateval
        self.datestr = datestr
        self.place = place
        self.cause = cause
        self.description = description
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if objref is None:
            self.objref = []
        else:
            self.objref = objref
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if event.subclass:
            return event.subclass(*args_, **kwargs_)
        else:
            return event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_daterange(self): return self.daterange
    def set_daterange(self, daterange): self.daterange = daterange
    def get_datespan(self): return self.datespan
    def set_datespan(self, datespan): self.datespan = datespan
    def get_dateval(self): return self.dateval
    def set_dateval(self, dateval): self.dateval = dateval
    def get_datestr(self): return self.datestr
    def set_datestr(self, datestr): self.datestr = datestr
    def get_place(self): return self.place
    def set_place(self, place): self.place = place
    def get_cause(self): return self.cause
    def set_cause(self, cause): self.cause = cause
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_objref(self): return self.objref
    def set_objref(self, objref): self.objref = objref
    def add_objref(self, value): self.objref.append(value)
    def insert_objref_at(self, index, value): self.objref.insert(index, value)
    def replace_objref_at(self, index, value): self.objref[index] = value
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.daterange is not None or
            self.datespan is not None or
            self.dateval is not None or
            self.datestr is not None or
            self.place is not None or
            self.cause is not None or
            self.description is not None or
            self.attribute or
            self.noteref or
            self.citationref or
            self.objref or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='event', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='event'):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_='gramps:', name_='type', pretty_print=pretty_print)
        if self.daterange is not None:
            self.daterange.export(outfile, level, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
        if self.datespan is not None:
            self.datespan.export(outfile, level, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
        if self.dateval is not None:
            self.dateval.export(outfile, level, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
        if self.datestr is not None:
            self.datestr.export(outfile, level, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
        if self.place is not None:
            self.place.export(outfile, level, namespace_='gramps:', name_='place', pretty_print=pretty_print)
        if self.cause is not None:
            self.cause.export(outfile, level, namespace_='gramps:', name_='cause', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_='gramps:', name_='description', pretty_print=pretty_print)
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_='gramps:', name_='attribute', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for objref_ in self.objref:
            objref_.export(outfile, level, namespace_='gramps:', name_='objref', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='event'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.type_(\n')
            self.type_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.daterange is not None:
            showIndent(outfile, level)
            outfile.write('daterange=model_.daterange(\n')
            self.daterange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datespan is not None:
            showIndent(outfile, level)
            outfile.write('datespan=model_.datespan(\n')
            self.datespan.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateval is not None:
            showIndent(outfile, level)
            outfile.write('dateval=model_.dateval(\n')
            self.dateval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datestr is not None:
            showIndent(outfile, level)
            outfile.write('datestr=model_.datestr(\n')
            self.datestr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.place is not None:
            showIndent(outfile, level)
            outfile.write('place=model_.place(\n')
            self.place.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cause is not None:
            showIndent(outfile, level)
            outfile.write('cause=model_.cause(\n')
            self.cause.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('objref=[\n')
        level += 1
        for objref_ in self.objref:
            showIndent(outfile, level)
            outfile.write('model_.objref(\n')
            objref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'daterange':
            obj_ = daterange.factory()
            obj_.build(child_)
            self.daterange = obj_
            obj_.original_tagname_ = 'daterange'
        elif nodeName_ == 'datespan':
            obj_ = datespan.factory()
            obj_.build(child_)
            self.datespan = obj_
            obj_.original_tagname_ = 'datespan'
        elif nodeName_ == 'dateval':
            obj_ = dateval.factory()
            obj_.build(child_)
            self.dateval = obj_
            obj_.original_tagname_ = 'dateval'
        elif nodeName_ == 'datestr':
            obj_ = datestr.factory()
            obj_.build(child_)
            self.datestr = obj_
            obj_.original_tagname_ = 'datestr'
        elif nodeName_ == 'place':
            obj_ = place.factory()
            obj_.build(child_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'cause':
            obj_ = cause.factory()
            obj_.build(child_)
            self.cause = obj_
            obj_.original_tagname_ = 'cause'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'objref':
            obj_ = objref.factory()
            obj_.build(child_)
            self.objref.append(obj_)
            obj_.original_tagname_ = 'objref'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class event


class sources(GeneratedsSuper):
    member_data_items_ = {
        'source': MemberSpec_('source', 'source', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, source=None):
        self.original_tagname_ = None
        if source is None:
            self.source = []
        else:
            self.source = source
    def factory(*args_, **kwargs_):
        if sources.subclass:
            return sources.subclass(*args_, **kwargs_)
        else:
            return sources(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def add_source(self, value): self.source.append(value)
    def insert_source_at(self, index, value): self.source.insert(index, value)
    def replace_source_at(self, index, value): self.source[index] = value
    def hasContent_(self):
        if (
            self.source
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='sources', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sources')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='sources', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='sources'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='sources', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for source_ in self.source:
            source_.export(outfile, level, namespace_='gramps:', name_='source', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='sources'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('source=[\n')
        level += 1
        for source_ in self.source:
            showIndent(outfile, level)
            outfile.write('model_.source(\n')
            source_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.source.append(obj_)
            obj_.original_tagname_ = 'source'
# end class sources


class source(GeneratedsSuper):
    member_data_items_ = {
        'handle': MemberSpec_('handle', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'stitle': MemberSpec_('stitle', 'stitle', 0),
        'sauthor': MemberSpec_('sauthor', 'sauthor', 0),
        'spubinfo': MemberSpec_('spubinfo', 'spubinfo', 0),
        'sabbrev': MemberSpec_('sabbrev', 'sabbrev', 0),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'objref': MemberSpec_('objref', 'objref', 1),
        'srcattribute': MemberSpec_('srcattribute', 'srcattribute', 1),
        'reporef': MemberSpec_('reporef', 'reporef', 1),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, handle=None, id=None, change=None, priv=None, stitle=None, sauthor=None, spubinfo=None, sabbrev=None, noteref=None, objref=None, srcattribute=None, reporef=None, tagref=None):
        self.original_tagname_ = None
        self.handle = _cast(None, handle)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.stitle = stitle
        self.sauthor = sauthor
        self.spubinfo = spubinfo
        self.sabbrev = sabbrev
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if objref is None:
            self.objref = []
        else:
            self.objref = objref
        if srcattribute is None:
            self.srcattribute = []
        else:
            self.srcattribute = srcattribute
        if reporef is None:
            self.reporef = []
        else:
            self.reporef = reporef
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stitle(self): return self.stitle
    def set_stitle(self, stitle): self.stitle = stitle
    def get_sauthor(self): return self.sauthor
    def set_sauthor(self, sauthor): self.sauthor = sauthor
    def get_spubinfo(self): return self.spubinfo
    def set_spubinfo(self, spubinfo): self.spubinfo = spubinfo
    def get_sabbrev(self): return self.sabbrev
    def set_sabbrev(self, sabbrev): self.sabbrev = sabbrev
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_objref(self): return self.objref
    def set_objref(self, objref): self.objref = objref
    def add_objref(self, value): self.objref.append(value)
    def insert_objref_at(self, index, value): self.objref.insert(index, value)
    def replace_objref_at(self, index, value): self.objref[index] = value
    def get_srcattribute(self): return self.srcattribute
    def set_srcattribute(self, srcattribute): self.srcattribute = srcattribute
    def add_srcattribute(self, value): self.srcattribute.append(value)
    def insert_srcattribute_at(self, index, value): self.srcattribute.insert(index, value)
    def replace_srcattribute_at(self, index, value): self.srcattribute[index] = value
    def get_reporef(self): return self.reporef
    def set_reporef(self, reporef): self.reporef = reporef
    def add_reporef(self, value): self.reporef.append(value)
    def insert_reporef_at(self, index, value): self.reporef.insert(index, value)
    def replace_reporef_at(self, index, value): self.reporef[index] = value
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.stitle is not None or
            self.sauthor is not None or
            self.spubinfo is not None or
            self.sabbrev is not None or
            self.noteref or
            self.objref or
            self.srcattribute or
            self.reporef or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='source', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='source', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='source'):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='source', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stitle is not None:
            self.stitle.export(outfile, level, namespace_='gramps:', name_='stitle', pretty_print=pretty_print)
        if self.sauthor is not None:
            self.sauthor.export(outfile, level, namespace_='gramps:', name_='sauthor', pretty_print=pretty_print)
        if self.spubinfo is not None:
            self.spubinfo.export(outfile, level, namespace_='gramps:', name_='spubinfo', pretty_print=pretty_print)
        if self.sabbrev is not None:
            self.sabbrev.export(outfile, level, namespace_='gramps:', name_='sabbrev', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for objref_ in self.objref:
            objref_.export(outfile, level, namespace_='gramps:', name_='objref', pretty_print=pretty_print)
        for srcattribute_ in self.srcattribute:
            srcattribute_.export(outfile, level, namespace_='gramps:', name_='srcattribute', pretty_print=pretty_print)
        for reporef_ in self.reporef:
            reporef_.export(outfile, level, namespace_='gramps:', name_='reporef', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.stitle is not None:
            showIndent(outfile, level)
            outfile.write('stitle=model_.stitle(\n')
            self.stitle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sauthor is not None:
            showIndent(outfile, level)
            outfile.write('sauthor=model_.sauthor(\n')
            self.sauthor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spubinfo is not None:
            showIndent(outfile, level)
            outfile.write('spubinfo=model_.spubinfo(\n')
            self.spubinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sabbrev is not None:
            showIndent(outfile, level)
            outfile.write('sabbrev=model_.sabbrev(\n')
            self.sabbrev.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('objref=[\n')
        level += 1
        for objref_ in self.objref:
            showIndent(outfile, level)
            outfile.write('model_.objref(\n')
            objref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('srcattribute=[\n')
        level += 1
        for srcattribute_ in self.srcattribute:
            showIndent(outfile, level)
            outfile.write('model_.srcattribute(\n')
            srcattribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reporef=[\n')
        level += 1
        for reporef_ in self.reporef:
            showIndent(outfile, level)
            outfile.write('model_.reporef(\n')
            reporef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stitle':
            obj_ = stitle.factory()
            obj_.build(child_)
            self.stitle = obj_
            obj_.original_tagname_ = 'stitle'
        elif nodeName_ == 'sauthor':
            obj_ = sauthor.factory()
            obj_.build(child_)
            self.sauthor = obj_
            obj_.original_tagname_ = 'sauthor'
        elif nodeName_ == 'spubinfo':
            obj_ = spubinfo.factory()
            obj_.build(child_)
            self.spubinfo = obj_
            obj_.original_tagname_ = 'spubinfo'
        elif nodeName_ == 'sabbrev':
            obj_ = sabbrev.factory()
            obj_.build(child_)
            self.sabbrev = obj_
            obj_.original_tagname_ = 'sabbrev'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'objref':
            obj_ = objref.factory()
            obj_.build(child_)
            self.objref.append(obj_)
            obj_.original_tagname_ = 'objref'
        elif nodeName_ == 'srcattribute':
            obj_ = srcattribute.factory()
            obj_.build(child_)
            self.srcattribute.append(obj_)
            obj_.original_tagname_ = 'srcattribute'
        elif nodeName_ == 'reporef':
            obj_ = reporef.factory()
            obj_.build(child_)
            self.reporef.append(obj_)
            obj_.original_tagname_ = 'reporef'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class source


class stitle(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if stitle.subclass:
            return stitle.subclass(*args_, **kwargs_)
        else:
            return stitle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='stitle', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stitle')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='stitle'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='stitle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='stitle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class stitle


class sauthor(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sauthor.subclass:
            return sauthor.subclass(*args_, **kwargs_)
        else:
            return sauthor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='sauthor', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sauthor')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='sauthor'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='sauthor', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='sauthor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class sauthor


class spubinfo(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if spubinfo.subclass:
            return spubinfo.subclass(*args_, **kwargs_)
        else:
            return spubinfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='spubinfo', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='spubinfo')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='spubinfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='spubinfo', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='spubinfo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class spubinfo


class sabbrev(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sabbrev.subclass:
            return sabbrev.subclass(*args_, **kwargs_)
        else:
            return sabbrev(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='sabbrev', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sabbrev')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='sabbrev'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='sabbrev', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='sabbrev'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class sabbrev


class places(GeneratedsSuper):
    member_data_items_ = {
        'placeobj': MemberSpec_('placeobj', 'placeobj', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, placeobj=None):
        self.original_tagname_ = None
        if placeobj is None:
            self.placeobj = []
        else:
            self.placeobj = placeobj
    def factory(*args_, **kwargs_):
        if places.subclass:
            return places.subclass(*args_, **kwargs_)
        else:
            return places(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_placeobj(self): return self.placeobj
    def set_placeobj(self, placeobj): self.placeobj = placeobj
    def add_placeobj(self, value): self.placeobj.append(value)
    def insert_placeobj_at(self, index, value): self.placeobj.insert(index, value)
    def replace_placeobj_at(self, index, value): self.placeobj[index] = value
    def hasContent_(self):
        if (
            self.placeobj
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='places', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='places')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='places', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='places'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='places', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for placeobj_ in self.placeobj:
            placeobj_.export(outfile, level, namespace_='gramps:', name_='placeobj', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='places'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('placeobj=[\n')
        level += 1
        for placeobj_ in self.placeobj:
            showIndent(outfile, level)
            outfile.write('model_.placeobj(\n')
            placeobj_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'placeobj':
            obj_ = placeobj.factory()
            obj_.build(child_)
            self.placeobj.append(obj_)
            obj_.original_tagname_ = 'placeobj'
# end class places


class placeobj(GeneratedsSuper):
    member_data_items_ = {
        'type': MemberSpec_('type', 'string', 0),
        'handle': MemberSpec_('handle', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'ptitle': MemberSpec_('ptitle', 'ptitle', 0),
        'pname': MemberSpec_('pname', 'pname', 1),
        'code': MemberSpec_('code', 'code', 0),
        'coord': MemberSpec_('coord', 'coord', 0),
        'placeref': MemberSpec_('placeref', 'placeref', 1),
        'location': MemberSpec_('location', 'location', 1),
        'objref': MemberSpec_('objref', 'objref', 1),
        'url': MemberSpec_('url', 'url', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, handle=None, id=None, change=None, priv=None, ptitle=None, pname=None, code=None, coord=None, placeref=None, location=None, objref=None, url=None, noteref=None, citationref=None, tagref=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.handle = _cast(None, handle)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.ptitle = ptitle
        if pname is None:
            self.pname = []
        else:
            self.pname = pname
        self.code = code
        self.coord = coord
        if placeref is None:
            self.placeref = []
        else:
            self.placeref = placeref
        if location is None:
            self.location = []
        else:
            self.location = location
        if objref is None:
            self.objref = []
        else:
            self.objref = objref
        if url is None:
            self.url = []
        else:
            self.url = url
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if placeobj.subclass:
            return placeobj.subclass(*args_, **kwargs_)
        else:
            return placeobj(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ptitle(self): return self.ptitle
    def set_ptitle(self, ptitle): self.ptitle = ptitle
    def get_pname(self): return self.pname
    def set_pname(self, pname): self.pname = pname
    def add_pname(self, value): self.pname.append(value)
    def insert_pname_at(self, index, value): self.pname.insert(index, value)
    def replace_pname_at(self, index, value): self.pname[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def get_placeref(self): return self.placeref
    def set_placeref(self, placeref): self.placeref = placeref
    def add_placeref(self, value): self.placeref.append(value)
    def insert_placeref_at(self, index, value): self.placeref.insert(index, value)
    def replace_placeref_at(self, index, value): self.placeref[index] = value
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def add_location(self, value): self.location.append(value)
    def insert_location_at(self, index, value): self.location.insert(index, value)
    def replace_location_at(self, index, value): self.location[index] = value
    def get_objref(self): return self.objref
    def set_objref(self, objref): self.objref = objref
    def add_objref(self, value): self.objref.append(value)
    def insert_objref_at(self, index, value): self.objref.insert(index, value)
    def replace_objref_at(self, index, value): self.objref[index] = value
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def add_url(self, value): self.url.append(value)
    def insert_url_at(self, index, value): self.url.insert(index, value)
    def replace_url_at(self, index, value): self.url[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.ptitle is not None or
            self.pname or
            self.code is not None or
            self.coord is not None or
            self.placeref or
            self.location or
            self.objref or
            self.url or
            self.noteref or
            self.citationref or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='placeobj', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='placeobj')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='placeobj', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='placeobj'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='placeobj', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ptitle is not None:
            self.ptitle.export(outfile, level, namespace_='gramps:', name_='ptitle', pretty_print=pretty_print)
        for pname_ in self.pname:
            pname_.export(outfile, level, namespace_='gramps:', name_='pname', pretty_print=pretty_print)
        if self.code is not None:
            self.code.export(outfile, level, namespace_='gramps:', name_='code', pretty_print=pretty_print)
        if self.coord is not None:
            self.coord.export(outfile, level, namespace_='gramps:', name_='coord', pretty_print=pretty_print)
        for placeref_ in self.placeref:
            placeref_.export(outfile, level, namespace_='gramps:', name_='placeref', pretty_print=pretty_print)
        for location_ in self.location:
            location_.export(outfile, level, namespace_='gramps:', name_='location', pretty_print=pretty_print)
        for objref_ in self.objref:
            objref_.export(outfile, level, namespace_='gramps:', name_='objref', pretty_print=pretty_print)
        for url_ in self.url:
            url_.export(outfile, level, namespace_='gramps:', name_='url', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='placeobj'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ptitle is not None:
            showIndent(outfile, level)
            outfile.write('ptitle=model_.ptitle(\n')
            self.ptitle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('pname=[\n')
        level += 1
        for pname_ in self.pname:
            showIndent(outfile, level)
            outfile.write('model_.pname(\n')
            pname_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=model_.code(\n')
            self.code.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coord is not None:
            showIndent(outfile, level)
            outfile.write('coord=model_.coord(\n')
            self.coord.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('placeref=[\n')
        level += 1
        for placeref_ in self.placeref:
            showIndent(outfile, level)
            outfile.write('model_.placeref(\n')
            placeref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('location=[\n')
        level += 1
        for location_ in self.location:
            showIndent(outfile, level)
            outfile.write('model_.location(\n')
            location_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('objref=[\n')
        level += 1
        for objref_ in self.objref:
            showIndent(outfile, level)
            outfile.write('model_.objref(\n')
            objref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('url=[\n')
        level += 1
        for url_ in self.url:
            showIndent(outfile, level)
            outfile.write('model_.url(\n')
            url_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ptitle':
            obj_ = ptitle.factory()
            obj_.build(child_)
            self.ptitle = obj_
            obj_.original_tagname_ = 'ptitle'
        elif nodeName_ == 'pname':
            obj_ = pname.factory()
            obj_.build(child_)
            self.pname.append(obj_)
            obj_.original_tagname_ = 'pname'
        elif nodeName_ == 'code':
            obj_ = code.factory()
            obj_.build(child_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'coord':
            obj_ = coord.factory()
            obj_.build(child_)
            self.coord = obj_
            obj_.original_tagname_ = 'coord'
        elif nodeName_ == 'placeref':
            obj_ = placeref.factory()
            obj_.build(child_)
            self.placeref.append(obj_)
            obj_.original_tagname_ = 'placeref'
        elif nodeName_ == 'location':
            obj_ = location.factory()
            obj_.build(child_)
            self.location.append(obj_)
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'objref':
            obj_ = objref.factory()
            obj_.build(child_)
            self.objref.append(obj_)
            obj_.original_tagname_ = 'objref'
        elif nodeName_ == 'url':
            obj_ = url.factory()
            obj_.build(child_)
            self.url.append(obj_)
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class placeobj


class pname(GeneratedsSuper):
    member_data_items_ = {
        'lang': MemberSpec_('lang', 'string', 0),
        'value': MemberSpec_('value', 'string', 0),
        'daterange': MemberSpec_('daterange', 'daterange', 0),
        'datespan': MemberSpec_('datespan', 'datespan', 0),
        'dateval': MemberSpec_('dateval', 'dateval', 0),
        'datestr': MemberSpec_('datestr', 'datestr', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lang=None, value=None, daterange=None, datespan=None, dateval=None, datestr=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.value = _cast(None, value)
        self.daterange = daterange
        self.datespan = datespan
        self.dateval = dateval
        self.datestr = datestr
    def factory(*args_, **kwargs_):
        if pname.subclass:
            return pname.subclass(*args_, **kwargs_)
        else:
            return pname(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_daterange(self): return self.daterange
    def set_daterange(self, daterange): self.daterange = daterange
    def get_datespan(self): return self.datespan
    def set_datespan(self, datespan): self.datespan = datespan
    def get_dateval(self): return self.dateval
    def set_dateval(self, dateval): self.dateval = dateval
    def get_datestr(self): return self.datestr
    def set_datestr(self, datestr): self.datestr = datestr
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.daterange is not None or
            self.datespan is not None or
            self.dateval is not None or
            self.datestr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='pname', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pname')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='pname', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='pname'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='pname', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.daterange is not None:
            self.daterange.export(outfile, level, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
        if self.datespan is not None:
            self.datespan.export(outfile, level, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
        if self.dateval is not None:
            self.dateval.export(outfile, level, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
        if self.datestr is not None:
            self.datestr.export(outfile, level, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='pname'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.daterange is not None:
            showIndent(outfile, level)
            outfile.write('daterange=model_.daterange(\n')
            self.daterange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datespan is not None:
            showIndent(outfile, level)
            outfile.write('datespan=model_.datespan(\n')
            self.datespan.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateval is not None:
            showIndent(outfile, level)
            outfile.write('dateval=model_.dateval(\n')
            self.dateval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datestr is not None:
            showIndent(outfile, level)
            outfile.write('datestr=model_.datestr(\n')
            self.datestr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'daterange':
            obj_ = daterange.factory()
            obj_.build(child_)
            self.daterange = obj_
            obj_.original_tagname_ = 'daterange'
        elif nodeName_ == 'datespan':
            obj_ = datespan.factory()
            obj_.build(child_)
            self.datespan = obj_
            obj_.original_tagname_ = 'datespan'
        elif nodeName_ == 'dateval':
            obj_ = dateval.factory()
            obj_.build(child_)
            self.dateval = obj_
            obj_.original_tagname_ = 'dateval'
        elif nodeName_ == 'datestr':
            obj_ = datestr.factory()
            obj_.build(child_)
            self.datestr = obj_
            obj_.original_tagname_ = 'datestr'
# end class pname


class ptitle(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ptitle.subclass:
            return ptitle.subclass(*args_, **kwargs_)
        else:
            return ptitle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='ptitle', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ptitle')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='ptitle'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='ptitle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ptitle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ptitle


class code(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if code.subclass:
            return code.subclass(*args_, **kwargs_)
        else:
            return code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='code', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='code')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='code'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='code', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='code'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class code


class coord(GeneratedsSuper):
    member_data_items_ = {
        'lat': MemberSpec_('lat', 'string', 0),
        'long': MemberSpec_('long', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lat=None, long=None):
        self.original_tagname_ = None
        self.lat = _cast(None, lat)
        self.long = _cast(None, long)
    def factory(*args_, **kwargs_):
        if coord.subclass:
            return coord.subclass(*args_, **kwargs_)
        else:
            return coord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lat(self): return self.lat
    def set_lat(self, lat): self.lat = lat
    def get_long(self): return self.long
    def set_long(self, long): self.long = long
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='coord', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='coord', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='coord'):
        if self.lat is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            outfile.write(' lat=%s' % (self.gds_format_string(quote_attrib(self.lat).encode(ExternalEncoding), input_name='lat'), ))
        if self.long is not None and 'long' not in already_processed:
            already_processed.add('long')
            outfile.write(' long=%s' % (self.gds_format_string(quote_attrib(self.long).encode(ExternalEncoding), input_name='long'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='coord', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='coord'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lat is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            showIndent(outfile, level)
            outfile.write('lat="%s",\n' % (self.lat,))
        if self.long is not None and 'long' not in already_processed:
            already_processed.add('long')
            showIndent(outfile, level)
            outfile.write('long="%s",\n' % (self.long,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lat', node)
        if value is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            self.lat = value
        value = find_attr_value_('long', node)
        if value is not None and 'long' not in already_processed:
            already_processed.add('long')
            self.long = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class coord


class location(GeneratedsSuper):
    member_data_items_ = {
        'city': MemberSpec_('city', 'string', 0),
        'locality': MemberSpec_('locality', 'string', 0),
        'parish': MemberSpec_('parish', 'string', 0),
        'county': MemberSpec_('county', 'string', 0),
        'phone': MemberSpec_('phone', 'string', 0),
        'state': MemberSpec_('state', 'string', 0),
        'street': MemberSpec_('street', 'string', 0),
        'country': MemberSpec_('country', 'string', 0),
        'postal': MemberSpec_('postal', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, city=None, locality=None, parish=None, county=None, phone=None, state=None, street=None, country=None, postal=None):
        self.original_tagname_ = None
        self.city = _cast(None, city)
        self.locality = _cast(None, locality)
        self.parish = _cast(None, parish)
        self.county = _cast(None, county)
        self.phone = _cast(None, phone)
        self.state = _cast(None, state)
        self.street = _cast(None, street)
        self.country = _cast(None, country)
        self.postal = _cast(None, postal)
    def factory(*args_, **kwargs_):
        if location.subclass:
            return location.subclass(*args_, **kwargs_)
        else:
            return location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_locality(self): return self.locality
    def set_locality(self, locality): self.locality = locality
    def get_parish(self): return self.parish
    def set_parish(self, parish): self.parish = parish
    def get_county(self): return self.county
    def set_county(self, county): self.county = county
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_street(self): return self.street
    def set_street(self, street): self.street = street
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_postal(self): return self.postal
    def set_postal(self, postal): self.postal = postal
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='location', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='location', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='location'):
        if self.city is not None and 'city' not in already_processed:
            already_processed.add('city')
            outfile.write(' city=%s' % (self.gds_format_string(quote_attrib(self.city).encode(ExternalEncoding), input_name='city'), ))
        if self.locality is not None and 'locality' not in already_processed:
            already_processed.add('locality')
            outfile.write(' locality=%s' % (self.gds_format_string(quote_attrib(self.locality).encode(ExternalEncoding), input_name='locality'), ))
        if self.parish is not None and 'parish' not in already_processed:
            already_processed.add('parish')
            outfile.write(' parish=%s' % (self.gds_format_string(quote_attrib(self.parish).encode(ExternalEncoding), input_name='parish'), ))
        if self.county is not None and 'county' not in already_processed:
            already_processed.add('county')
            outfile.write(' county=%s' % (self.gds_format_string(quote_attrib(self.county).encode(ExternalEncoding), input_name='county'), ))
        if self.phone is not None and 'phone' not in already_processed:
            already_processed.add('phone')
            outfile.write(' phone=%s' % (self.gds_format_string(quote_attrib(self.phone).encode(ExternalEncoding), input_name='phone'), ))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
        if self.street is not None and 'street' not in already_processed:
            already_processed.add('street')
            outfile.write(' street=%s' % (self.gds_format_string(quote_attrib(self.street).encode(ExternalEncoding), input_name='street'), ))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (self.gds_format_string(quote_attrib(self.country).encode(ExternalEncoding), input_name='country'), ))
        if self.postal is not None and 'postal' not in already_processed:
            already_processed.add('postal')
            outfile.write(' postal=%s' % (self.gds_format_string(quote_attrib(self.postal).encode(ExternalEncoding), input_name='postal'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='location', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='location'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.city is not None and 'city' not in already_processed:
            already_processed.add('city')
            showIndent(outfile, level)
            outfile.write('city="%s",\n' % (self.city,))
        if self.locality is not None and 'locality' not in already_processed:
            already_processed.add('locality')
            showIndent(outfile, level)
            outfile.write('locality="%s",\n' % (self.locality,))
        if self.parish is not None and 'parish' not in already_processed:
            already_processed.add('parish')
            showIndent(outfile, level)
            outfile.write('parish="%s",\n' % (self.parish,))
        if self.county is not None and 'county' not in already_processed:
            already_processed.add('county')
            showIndent(outfile, level)
            outfile.write('county="%s",\n' % (self.county,))
        if self.phone is not None and 'phone' not in already_processed:
            already_processed.add('phone')
            showIndent(outfile, level)
            outfile.write('phone="%s",\n' % (self.phone,))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            showIndent(outfile, level)
            outfile.write('state="%s",\n' % (self.state,))
        if self.street is not None and 'street' not in already_processed:
            already_processed.add('street')
            showIndent(outfile, level)
            outfile.write('street="%s",\n' % (self.street,))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            showIndent(outfile, level)
            outfile.write('country="%s",\n' % (self.country,))
        if self.postal is not None and 'postal' not in already_processed:
            already_processed.add('postal')
            showIndent(outfile, level)
            outfile.write('postal="%s",\n' % (self.postal,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('city', node)
        if value is not None and 'city' not in already_processed:
            already_processed.add('city')
            self.city = value
        value = find_attr_value_('locality', node)
        if value is not None and 'locality' not in already_processed:
            already_processed.add('locality')
            self.locality = value
        value = find_attr_value_('parish', node)
        if value is not None and 'parish' not in already_processed:
            already_processed.add('parish')
            self.parish = value
        value = find_attr_value_('county', node)
        if value is not None and 'county' not in already_processed:
            already_processed.add('county')
            self.county = value
        value = find_attr_value_('phone', node)
        if value is not None and 'phone' not in already_processed:
            already_processed.add('phone')
            self.phone = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('street', node)
        if value is not None and 'street' not in already_processed:
            already_processed.add('street')
            self.street = value
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
        value = find_attr_value_('postal', node)
        if value is not None and 'postal' not in already_processed:
            already_processed.add('postal')
            self.postal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class location


class objects(GeneratedsSuper):
    member_data_items_ = {
        'object': MemberSpec_('object', 'object', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, object=None):
        self.original_tagname_ = None
        if object is None:
            self.object = []
        else:
            self.object = object
    def factory(*args_, **kwargs_):
        if objects.subclass:
            return objects.subclass(*args_, **kwargs_)
        else:
            return objects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def add_object(self, value): self.object.append(value)
    def insert_object_at(self, index, value): self.object.insert(index, value)
    def replace_object_at(self, index, value): self.object[index] = value
    def hasContent_(self):
        if (
            self.object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='objects', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objects')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='objects', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='objects'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='objects', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_ in self.object:
            object_.export(outfile, level, namespace_='gramps:', name_='object', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='objects'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('object=[\n')
        level += 1
        for object_ in self.object:
            showIndent(outfile, level)
            outfile.write('model_.object(\n')
            object_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object':
            obj_ = object.factory()
            obj_.build(child_)
            self.object.append(obj_)
            obj_.original_tagname_ = 'object'
# end class objects


class object(GeneratedsSuper):
    member_data_items_ = {
        'handle': MemberSpec_('handle', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'file': MemberSpec_('file', 'file', 0),
        'attribute': MemberSpec_('attribute', 'attribute', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'daterange': MemberSpec_('daterange', 'daterange', 0),
        'datespan': MemberSpec_('datespan', 'datespan', 0),
        'dateval': MemberSpec_('dateval', 'dateval', 0),
        'datestr': MemberSpec_('datestr', 'datestr', 0),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, handle=None, id=None, change=None, priv=None, file=None, attribute=None, noteref=None, daterange=None, datespan=None, dateval=None, datestr=None, citationref=None, tagref=None):
        self.original_tagname_ = None
        self.handle = _cast(None, handle)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.file = file
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        self.daterange = daterange
        self.datespan = datespan
        self.dateval = dateval
        self.datestr = datestr
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if object.subclass:
            return object.subclass(*args_, **kwargs_)
        else:
            return object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_daterange(self): return self.daterange
    def set_daterange(self, daterange): self.daterange = daterange
    def get_datespan(self): return self.datespan
    def set_datespan(self, datespan): self.datespan = datespan
    def get_dateval(self): return self.dateval
    def set_dateval(self, dateval): self.dateval = dateval
    def get_datestr(self): return self.datestr
    def set_datestr(self, datestr): self.datestr = datestr
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.file is not None or
            self.attribute or
            self.noteref or
            self.daterange is not None or
            self.datespan is not None or
            self.dateval is not None or
            self.datestr is not None or
            self.citationref or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='object', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='object')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='object', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='object'):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='object', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.file is not None:
            self.file.export(outfile, level, namespace_='gramps:', name_='file', pretty_print=pretty_print)
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_='gramps:', name_='attribute', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        if self.daterange is not None:
            self.daterange.export(outfile, level, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
        if self.datespan is not None:
            self.datespan.export(outfile, level, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
        if self.dateval is not None:
            self.dateval.export(outfile, level, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
        if self.datestr is not None:
            self.datestr.export(outfile, level, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='object'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.file is not None:
            showIndent(outfile, level)
            outfile.write('file=model_.file(\n')
            self.file.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.daterange is not None:
            showIndent(outfile, level)
            outfile.write('daterange=model_.daterange(\n')
            self.daterange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datespan is not None:
            showIndent(outfile, level)
            outfile.write('datespan=model_.datespan(\n')
            self.datespan.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateval is not None:
            showIndent(outfile, level)
            outfile.write('dateval=model_.dateval(\n')
            self.dateval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datestr is not None:
            showIndent(outfile, level)
            outfile.write('datestr=model_.datestr(\n')
            self.datestr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'file':
            obj_ = file.factory()
            obj_.build(child_)
            self.file = obj_
            obj_.original_tagname_ = 'file'
        elif nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'daterange':
            obj_ = daterange.factory()
            obj_.build(child_)
            self.daterange = obj_
            obj_.original_tagname_ = 'daterange'
        elif nodeName_ == 'datespan':
            obj_ = datespan.factory()
            obj_.build(child_)
            self.datespan = obj_
            obj_.original_tagname_ = 'datespan'
        elif nodeName_ == 'dateval':
            obj_ = dateval.factory()
            obj_.build(child_)
            self.dateval = obj_
            obj_.original_tagname_ = 'dateval'
        elif nodeName_ == 'datestr':
            obj_ = datestr.factory()
            obj_.build(child_)
            self.datestr = obj_
            obj_.original_tagname_ = 'datestr'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class object


class file(GeneratedsSuper):
    member_data_items_ = {
        'src': MemberSpec_('src', 'string', 0),
        'mime': MemberSpec_('mime', 'string', 0),
        'description': MemberSpec_('description', 'string', 0),
        'checksum': MemberSpec_('checksum', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, src=None, mime=None, description=None, checksum=None):
        self.original_tagname_ = None
        self.src = _cast(None, src)
        self.mime = _cast(None, mime)
        self.description = _cast(None, description)
        self.checksum = _cast(None, checksum)
    def factory(*args_, **kwargs_):
        if file.subclass:
            return file.subclass(*args_, **kwargs_)
        else:
            return file(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_mime(self): return self.mime
    def set_mime(self, mime): self.mime = mime
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_checksum(self): return self.checksum
    def set_checksum(self, checksum): self.checksum = checksum
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='file', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='file')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='file', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='file'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.add('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.mime is not None and 'mime' not in already_processed:
            already_processed.add('mime')
            outfile.write(' mime=%s' % (self.gds_format_string(quote_attrib(self.mime).encode(ExternalEncoding), input_name='mime'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_format_string(quote_attrib(self.checksum).encode(ExternalEncoding), input_name='checksum'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='file', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='file'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.add('src')
            showIndent(outfile, level)
            outfile.write('src="%s",\n' % (self.src,))
        if self.mime is not None and 'mime' not in already_processed:
            already_processed.add('mime')
            showIndent(outfile, level)
            outfile.write('mime="%s",\n' % (self.mime,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            showIndent(outfile, level)
            outfile.write('checksum="%s",\n' % (self.checksum,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('src', node)
        if value is not None and 'src' not in already_processed:
            already_processed.add('src')
            self.src = value
        value = find_attr_value_('mime', node)
        if value is not None and 'mime' not in already_processed:
            already_processed.add('mime')
            self.mime = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class file


class repositories(GeneratedsSuper):
    member_data_items_ = {
        'repository': MemberSpec_('repository', 'repository', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, repository=None):
        self.original_tagname_ = None
        if repository is None:
            self.repository = []
        else:
            self.repository = repository
    def factory(*args_, **kwargs_):
        if repositories.subclass:
            return repositories.subclass(*args_, **kwargs_)
        else:
            return repositories(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_repository(self): return self.repository
    def set_repository(self, repository): self.repository = repository
    def add_repository(self, value): self.repository.append(value)
    def insert_repository_at(self, index, value): self.repository.insert(index, value)
    def replace_repository_at(self, index, value): self.repository[index] = value
    def hasContent_(self):
        if (
            self.repository
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='repositories', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='repositories')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='repositories', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='repositories'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='repositories', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for repository_ in self.repository:
            repository_.export(outfile, level, namespace_='gramps:', name_='repository', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='repositories'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('repository=[\n')
        level += 1
        for repository_ in self.repository:
            showIndent(outfile, level)
            outfile.write('model_.repository(\n')
            repository_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'repository':
            obj_ = repository.factory()
            obj_.build(child_)
            self.repository.append(obj_)
            obj_.original_tagname_ = 'repository'
# end class repositories


class repository(GeneratedsSuper):
    member_data_items_ = {
        'handle': MemberSpec_('handle', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'rname': MemberSpec_('rname', 'rname', 0),
        'type_': MemberSpec_('type_', 'type', 0),
        'address': MemberSpec_('address', 'address', 1),
        'url': MemberSpec_('url', 'url', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, handle=None, id=None, change=None, priv=None, rname=None, type_=None, address=None, url=None, noteref=None, tagref=None):
        self.original_tagname_ = None
        self.handle = _cast(None, handle)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.rname = rname
        self.type_ = type_
        if address is None:
            self.address = []
        else:
            self.address = address
        if url is None:
            self.url = []
        else:
            self.url = url
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if repository.subclass:
            return repository.subclass(*args_, **kwargs_)
        else:
            return repository(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rname(self): return self.rname
    def set_rname(self, rname): self.rname = rname
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def add_address(self, value): self.address.append(value)
    def insert_address_at(self, index, value): self.address.insert(index, value)
    def replace_address_at(self, index, value): self.address[index] = value
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def add_url(self, value): self.url.append(value)
    def insert_url_at(self, index, value): self.url.insert(index, value)
    def replace_url_at(self, index, value): self.url[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.rname is not None or
            self.type_ is not None or
            self.address or
            self.url or
            self.noteref or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='repository', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='repository')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='repository', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='repository'):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='repository', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rname is not None:
            self.rname.export(outfile, level, namespace_='gramps:', name_='rname', pretty_print=pretty_print)
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_='gramps:', name_='type', pretty_print=pretty_print)
        for address_ in self.address:
            address_.export(outfile, level, namespace_='gramps:', name_='address', pretty_print=pretty_print)
        for url_ in self.url:
            url_.export(outfile, level, namespace_='gramps:', name_='url', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='repository'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rname is not None:
            showIndent(outfile, level)
            outfile.write('rname=model_.rname(\n')
            self.rname.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.type_(\n')
            self.type_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('address=[\n')
        level += 1
        for address_ in self.address:
            showIndent(outfile, level)
            outfile.write('model_.address(\n')
            address_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('url=[\n')
        level += 1
        for url_ in self.url:
            showIndent(outfile, level)
            outfile.write('model_.url(\n')
            url_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rname':
            obj_ = rname.factory()
            obj_.build(child_)
            self.rname = obj_
            obj_.original_tagname_ = 'rname'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'address':
            obj_ = address.factory()
            obj_.build(child_)
            self.address.append(obj_)
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'url':
            obj_ = url.factory()
            obj_.build(child_)
            self.url.append(obj_)
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class repository


class rname(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if rname.subclass:
            return rname.subclass(*args_, **kwargs_)
        else:
            return rname(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='rname', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rname')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='rname'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='rname', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rname'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class rname


class notes(GeneratedsSuper):
    member_data_items_ = {
        'note': MemberSpec_('note', 'note', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, note=None):
        self.original_tagname_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if notes.subclass:
            return notes.subclass(*args_, **kwargs_)
        else:
            return notes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note_at(self, index, value): self.note.insert(index, value)
    def replace_note_at(self, index, value): self.note[index] = value
    def hasContent_(self):
        if (
            self.note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='notes', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='notes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='notes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='notes'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='notes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for note_ in self.note:
            note_.export(outfile, level, namespace_='gramps:', name_='note', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='notes'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.note(\n')
            note_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'note':
            obj_ = note.factory()
            obj_.build(child_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
# end class notes


class note(GeneratedsSuper):
    member_data_items_ = {
        'handle': MemberSpec_('handle', 'string', 0),
        'format': MemberSpec_('format', 'string', 0),
        'type': MemberSpec_('type', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'text': MemberSpec_('text', 'text', 0),
        'style': MemberSpec_('style', 'style', 1),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, handle=None, format=None, type_=None, id=None, change=None, priv=None, text=None, style=None, tagref=None):
        self.original_tagname_ = None
        self.handle = _cast(None, handle)
        self.format = _cast(None, format)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.text = text
        if style is None:
            self.style = []
        else:
            self.style = style
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if note.subclass:
            return note.subclass(*args_, **kwargs_)
        else:
            return note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_style(self): return self.style
    def set_style(self, style): self.style = style
    def add_style(self, value): self.style.append(value)
    def insert_style_at(self, index, value): self.style.insert(index, value)
    def replace_style_at(self, index, value): self.style[index] = value
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.text is not None or
            self.style or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='note', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='note')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='note', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='note'):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            outfile.write(' format=%s' % (self.gds_format_string(quote_attrib(self.format).encode(ExternalEncoding), input_name='format'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='note', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.text is not None:
            self.text.export(outfile, level, namespace_='gramps:', name_='text', pretty_print=pretty_print)
        for style_ in self.style:
            style_.export(outfile, level, namespace_='gramps:', name_='style', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='note'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            showIndent(outfile, level)
            outfile.write('format="%s",\n' % (self.format,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.text is not None:
            showIndent(outfile, level)
            outfile.write('text=model_.text(\n')
            self.text.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('style=[\n')
        level += 1
        for style_ in self.style:
            showIndent(outfile, level)
            outfile.write('model_.style(\n')
            style_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.add('format')
            self.format = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'style':
            obj_ = style.factory()
            obj_.build(child_)
            self.style.append(obj_)
            obj_.original_tagname_ = 'style'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class note


class text(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if text.subclass:
            return text.subclass(*args_, **kwargs_)
        else:
            return text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='text', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='text')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='text'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='text', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='text'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class text


class style(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'string', 0),
        'value': MemberSpec_('value', 'string', 0),
        'range_': MemberSpec_('range_', 'range', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, range_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        if range_ is None:
            self.range_ = []
        else:
            self.range_ = range_
    def factory(*args_, **kwargs_):
        if style.subclass:
            return style.subclass(*args_, **kwargs_)
        else:
            return style(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_range(self): return self.range_
    def set_range(self, range_): self.range_ = range_
    def add_range(self, value): self.range_.append(value)
    def insert_range_at(self, index, value): self.range_.insert(index, value)
    def replace_range_at(self, index, value): self.range_[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.range_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='style', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='style')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='style', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='style'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='style', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for range_ in self.range_:
            range_.export(outfile, level, namespace_='gramps:', name_='range', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='style'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('range_=[\n')
        level += 1
        for range_ in self.range_:
            showIndent(outfile, level)
            outfile.write('model_.range_(\n')
            range_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'range':
            obj_ = range_.factory()
            obj_.build(child_)
            self.range_.append(obj_)
            obj_.original_tagname_ = 'range'
# end class style


class range_(GeneratedsSuper):
    member_data_items_ = {
        'start': MemberSpec_('start', 'string', 0),
        'end': MemberSpec_('end', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, start=None, end=None):
        self.original_tagname_ = None
        self.start = _cast(None, start)
        self.end = _cast(None, end)
    def factory(*args_, **kwargs_):
        if range_.subclass:
            return range_.subclass(*args_, **kwargs_)
        else:
            return range_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='range', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='range')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='range', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='range'):
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_format_string(quote_attrib(self.start).encode(ExternalEncoding), input_name='start'), ))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            outfile.write(' end=%s' % (self.gds_format_string(quote_attrib(self.end).encode(ExternalEncoding), input_name='end'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='range', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='range'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start="%s",\n' % (self.start,))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            showIndent(outfile, level)
            outfile.write('end="%s",\n' % (self.end,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
        value = find_attr_value_('end', node)
        if value is not None and 'end' not in already_processed:
            already_processed.add('end')
            self.end = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class range_


class tags(GeneratedsSuper):
    member_data_items_ = {
        'tag': MemberSpec_('tag', 'tag', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, tag=None):
        self.original_tagname_ = None
        if tag is None:
            self.tag = []
        else:
            self.tag = tag
    def factory(*args_, **kwargs_):
        if tags.subclass:
            return tags.subclass(*args_, **kwargs_)
        else:
            return tags(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tag(self): return self.tag
    def set_tag(self, tag): self.tag = tag
    def add_tag(self, value): self.tag.append(value)
    def insert_tag_at(self, index, value): self.tag.insert(index, value)
    def replace_tag_at(self, index, value): self.tag[index] = value
    def hasContent_(self):
        if (
            self.tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='tags', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tags')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='tags', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='tags'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='tags', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tag_ in self.tag:
            tag_.export(outfile, level, namespace_='gramps:', name_='tag', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='tags'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tag=[\n')
        level += 1
        for tag_ in self.tag:
            showIndent(outfile, level)
            outfile.write('model_.tag(\n')
            tag_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag':
            obj_ = tag.factory()
            obj_.build(child_)
            self.tag.append(obj_)
            obj_.original_tagname_ = 'tag'
# end class tags


class tag(GeneratedsSuper):
    member_data_items_ = {
        'color': MemberSpec_('color', 'string', 0),
        'priority': MemberSpec_('priority', 'string', 0),
        'handle': MemberSpec_('handle', 'string', 0),
        'name': MemberSpec_('name', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, color=None, priority=None, handle=None, name=None, change=None):
        self.original_tagname_ = None
        self.color = _cast(None, color)
        self.priority = _cast(None, priority)
        self.handle = _cast(None, handle)
        self.name = _cast(None, name)
        self.change = _cast(None, change)
    def factory(*args_, **kwargs_):
        if tag.subclass:
            return tag.subclass(*args_, **kwargs_)
        else:
            return tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_color(self): return self.color
    def set_color(self, color): self.color = color
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='tag', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='tag', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='tag'):
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_format_string(quote_attrib(self.color).encode(ExternalEncoding), input_name='color'), ))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority=%s' % (self.gds_format_string(quote_attrib(self.priority).encode(ExternalEncoding), input_name='priority'), ))
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='tag', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='tag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            showIndent(outfile, level)
            outfile.write('color="%s",\n' % (self.color,))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            showIndent(outfile, level)
            outfile.write('priority="%s",\n' % (self.priority,))
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            self.priority = value
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tag


class citations(GeneratedsSuper):
    member_data_items_ = {
        'citation': MemberSpec_('citation', 'citation', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, citation=None):
        self.original_tagname_ = None
        if citation is None:
            self.citation = []
        else:
            self.citation = citation
    def factory(*args_, **kwargs_):
        if citations.subclass:
            return citations.subclass(*args_, **kwargs_)
        else:
            return citations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_citation(self): return self.citation
    def set_citation(self, citation): self.citation = citation
    def add_citation(self, value): self.citation.append(value)
    def insert_citation_at(self, index, value): self.citation.insert(index, value)
    def replace_citation_at(self, index, value): self.citation[index] = value
    def hasContent_(self):
        if (
            self.citation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='citations', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='citations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='citations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='citations'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='citations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for citation_ in self.citation:
            citation_.export(outfile, level, namespace_='gramps:', name_='citation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='citations'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('citation=[\n')
        level += 1
        for citation_ in self.citation:
            showIndent(outfile, level)
            outfile.write('model_.citation(\n')
            citation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'citation':
            obj_ = citation.factory()
            obj_.build(child_)
            self.citation.append(obj_)
            obj_.original_tagname_ = 'citation'
# end class citations


class citation(GeneratedsSuper):
    member_data_items_ = {
        'handle': MemberSpec_('handle', 'string', 0),
        'id': MemberSpec_('id', 'string', 0),
        'change': MemberSpec_('change', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'daterange': MemberSpec_('daterange', 'daterange', 0),
        'datespan': MemberSpec_('datespan', 'datespan', 0),
        'dateval': MemberSpec_('dateval', 'dateval', 0),
        'datestr': MemberSpec_('datestr', 'datestr', 0),
        'page': MemberSpec_('page', 'page', 0),
        'confidence': MemberSpec_('confidence', 'confidence', 0),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'objref': MemberSpec_('objref', 'objref', 1),
        'srcattribute': MemberSpec_('srcattribute', 'srcattribute', 1),
        'sourceref': MemberSpec_('sourceref', 'sourceref', 0),
        'tagref': MemberSpec_('tagref', 'tagref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, handle=None, id=None, change=None, priv=None, daterange=None, datespan=None, dateval=None, datestr=None, page=None, confidence=None, noteref=None, objref=None, srcattribute=None, sourceref=None, tagref=None):
        self.original_tagname_ = None
        self.handle = _cast(None, handle)
        self.id = _cast(None, id)
        self.change = _cast(None, change)
        self.priv = _cast(None, priv)
        self.daterange = daterange
        self.datespan = datespan
        self.dateval = dateval
        self.datestr = datestr
        self.page = page
        self.confidence = confidence
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if objref is None:
            self.objref = []
        else:
            self.objref = objref
        if srcattribute is None:
            self.srcattribute = []
        else:
            self.srcattribute = srcattribute
        self.sourceref = sourceref
        if tagref is None:
            self.tagref = []
        else:
            self.tagref = tagref
    def factory(*args_, **kwargs_):
        if citation.subclass:
            return citation.subclass(*args_, **kwargs_)
        else:
            return citation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_daterange(self): return self.daterange
    def set_daterange(self, daterange): self.daterange = daterange
    def get_datespan(self): return self.datespan
    def set_datespan(self, datespan): self.datespan = datespan
    def get_dateval(self): return self.dateval
    def set_dateval(self, dateval): self.dateval = dateval
    def get_datestr(self): return self.datestr
    def set_datestr(self, datestr): self.datestr = datestr
    def get_page(self): return self.page
    def set_page(self, page): self.page = page
    def get_confidence(self): return self.confidence
    def set_confidence(self, confidence): self.confidence = confidence
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_objref(self): return self.objref
    def set_objref(self, objref): self.objref = objref
    def add_objref(self, value): self.objref.append(value)
    def insert_objref_at(self, index, value): self.objref.insert(index, value)
    def replace_objref_at(self, index, value): self.objref[index] = value
    def get_srcattribute(self): return self.srcattribute
    def set_srcattribute(self, srcattribute): self.srcattribute = srcattribute
    def add_srcattribute(self, value): self.srcattribute.append(value)
    def insert_srcattribute_at(self, index, value): self.srcattribute.insert(index, value)
    def replace_srcattribute_at(self, index, value): self.srcattribute[index] = value
    def get_sourceref(self): return self.sourceref
    def set_sourceref(self, sourceref): self.sourceref = sourceref
    def get_tagref(self): return self.tagref
    def set_tagref(self, tagref): self.tagref = tagref
    def add_tagref(self, value): self.tagref.append(value)
    def insert_tagref_at(self, index, value): self.tagref.insert(index, value)
    def replace_tagref_at(self, index, value): self.tagref[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.daterange is not None or
            self.datespan is not None or
            self.dateval is not None or
            self.datestr is not None or
            self.page is not None or
            self.confidence is not None or
            self.noteref or
            self.objref or
            self.srcattribute or
            self.sourceref is not None or
            self.tagref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='citation', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='citation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='citation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='citation'):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            outfile.write(' change=%s' % (self.gds_format_string(quote_attrib(self.change).encode(ExternalEncoding), input_name='change'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='citation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.daterange is not None:
            self.daterange.export(outfile, level, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
        if self.datespan is not None:
            self.datespan.export(outfile, level, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
        if self.dateval is not None:
            self.dateval.export(outfile, level, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
        if self.datestr is not None:
            self.datestr.export(outfile, level, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
        if self.page is not None:
            self.page.export(outfile, level, namespace_='gramps:', name_='page', pretty_print=pretty_print)
        if self.confidence is not None:
            self.confidence.export(outfile, level, namespace_='gramps:', name_='confidence', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for objref_ in self.objref:
            objref_.export(outfile, level, namespace_='gramps:', name_='objref', pretty_print=pretty_print)
        for srcattribute_ in self.srcattribute:
            srcattribute_.export(outfile, level, namespace_='gramps:', name_='srcattribute', pretty_print=pretty_print)
        if self.sourceref is not None:
            self.sourceref.export(outfile, level, namespace_='gramps:', name_='sourceref', pretty_print=pretty_print)
        for tagref_ in self.tagref:
            tagref_.export(outfile, level, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='citation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.change is not None and 'change' not in already_processed:
            already_processed.add('change')
            showIndent(outfile, level)
            outfile.write('change="%s",\n' % (self.change,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.daterange is not None:
            showIndent(outfile, level)
            outfile.write('daterange=model_.daterange(\n')
            self.daterange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datespan is not None:
            showIndent(outfile, level)
            outfile.write('datespan=model_.datespan(\n')
            self.datespan.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateval is not None:
            showIndent(outfile, level)
            outfile.write('dateval=model_.dateval(\n')
            self.dateval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datestr is not None:
            showIndent(outfile, level)
            outfile.write('datestr=model_.datestr(\n')
            self.datestr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.page is not None:
            showIndent(outfile, level)
            outfile.write('page=model_.page(\n')
            self.page.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.confidence is not None:
            showIndent(outfile, level)
            outfile.write('confidence=model_.confidence(\n')
            self.confidence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('objref=[\n')
        level += 1
        for objref_ in self.objref:
            showIndent(outfile, level)
            outfile.write('model_.objref(\n')
            objref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('srcattribute=[\n')
        level += 1
        for srcattribute_ in self.srcattribute:
            showIndent(outfile, level)
            outfile.write('model_.srcattribute(\n')
            srcattribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.sourceref is not None:
            showIndent(outfile, level)
            outfile.write('sourceref=model_.sourceref(\n')
            self.sourceref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('tagref=[\n')
        level += 1
        for tagref_ in self.tagref:
            showIndent(outfile, level)
            outfile.write('model_.tagref(\n')
            tagref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('change', node)
        if value is not None and 'change' not in already_processed:
            already_processed.add('change')
            self.change = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'daterange':
            obj_ = daterange.factory()
            obj_.build(child_)
            self.daterange = obj_
            obj_.original_tagname_ = 'daterange'
        elif nodeName_ == 'datespan':
            obj_ = datespan.factory()
            obj_.build(child_)
            self.datespan = obj_
            obj_.original_tagname_ = 'datespan'
        elif nodeName_ == 'dateval':
            obj_ = dateval.factory()
            obj_.build(child_)
            self.dateval = obj_
            obj_.original_tagname_ = 'dateval'
        elif nodeName_ == 'datestr':
            obj_ = datestr.factory()
            obj_.build(child_)
            self.datestr = obj_
            obj_.original_tagname_ = 'datestr'
        elif nodeName_ == 'page':
            obj_ = page.factory()
            obj_.build(child_)
            self.page = obj_
            obj_.original_tagname_ = 'page'
        elif nodeName_ == 'confidence':
            obj_ = confidence.factory()
            obj_.build(child_)
            self.confidence = obj_
            obj_.original_tagname_ = 'confidence'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'objref':
            obj_ = objref.factory()
            obj_.build(child_)
            self.objref.append(obj_)
            obj_.original_tagname_ = 'objref'
        elif nodeName_ == 'srcattribute':
            obj_ = srcattribute.factory()
            obj_.build(child_)
            self.srcattribute.append(obj_)
            obj_.original_tagname_ = 'srcattribute'
        elif nodeName_ == 'sourceref':
            obj_ = sourceref.factory()
            obj_.build(child_)
            self.sourceref = obj_
            obj_.original_tagname_ = 'sourceref'
        elif nodeName_ == 'tagref':
            obj_ = tagref.factory()
            obj_.build(child_)
            self.tagref.append(obj_)
            obj_.original_tagname_ = 'tagref'
# end class citation


class bookmarks(GeneratedsSuper):
    member_data_items_ = {
        'bookmark': MemberSpec_('bookmark', 'bookmark', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, bookmark=None):
        self.original_tagname_ = None
        if bookmark is None:
            self.bookmark = []
        else:
            self.bookmark = bookmark
    def factory(*args_, **kwargs_):
        if bookmarks.subclass:
            return bookmarks.subclass(*args_, **kwargs_)
        else:
            return bookmarks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bookmark(self): return self.bookmark
    def set_bookmark(self, bookmark): self.bookmark = bookmark
    def add_bookmark(self, value): self.bookmark.append(value)
    def insert_bookmark_at(self, index, value): self.bookmark.insert(index, value)
    def replace_bookmark_at(self, index, value): self.bookmark[index] = value
    def hasContent_(self):
        if (
            self.bookmark
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='bookmarks', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bookmarks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='bookmarks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='bookmarks'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='bookmarks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for bookmark_ in self.bookmark:
            bookmark_.export(outfile, level, namespace_='gramps:', name_='bookmark', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='bookmarks'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bookmark=[\n')
        level += 1
        for bookmark_ in self.bookmark:
            showIndent(outfile, level)
            outfile.write('model_.bookmark(\n')
            bookmark_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bookmark':
            obj_ = bookmark.factory()
            obj_.build(child_)
            self.bookmark.append(obj_)
            obj_.original_tagname_ = 'bookmark'
# end class bookmarks


class bookmark(GeneratedsSuper):
    member_data_items_ = {
        'target': MemberSpec_('target', 'string', 0),
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, target=None, hlink=None):
        self.original_tagname_ = None
        self.target = _cast(None, target)
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if bookmark.subclass:
            return bookmark.subclass(*args_, **kwargs_)
        else:
            return bookmark(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='bookmark', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bookmark')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='bookmark', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='bookmark'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding), input_name='target'), ))
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='bookmark', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='bookmark'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            showIndent(outfile, level)
            outfile.write('target="%s",\n' % (self.target,))
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bookmark


class namemaps(GeneratedsSuper):
    member_data_items_ = {
        'map': MemberSpec_('map', 'map', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, map=None):
        self.original_tagname_ = None
        if map is None:
            self.map = []
        else:
            self.map = map
    def factory(*args_, **kwargs_):
        if namemaps.subclass:
            return namemaps.subclass(*args_, **kwargs_)
        else:
            return namemaps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_map(self): return self.map
    def set_map(self, map): self.map = map
    def add_map(self, value): self.map.append(value)
    def insert_map_at(self, index, value): self.map.insert(index, value)
    def replace_map_at(self, index, value): self.map[index] = value
    def hasContent_(self):
        if (
            self.map
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='namemaps', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='namemaps')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='namemaps', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='namemaps'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='namemaps', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for map_ in self.map:
            map_.export(outfile, level, namespace_='gramps:', name_='map', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='namemaps'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('map=[\n')
        level += 1
        for map_ in self.map:
            showIndent(outfile, level)
            outfile.write('model_.map(\n')
            map_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'map':
            obj_ = map.factory()
            obj_.build(child_)
            self.map.append(obj_)
            obj_.original_tagname_ = 'map'
# end class namemaps


class map(GeneratedsSuper):
    member_data_items_ = {
        'type': MemberSpec_('type', 'string', 0),
        'value': MemberSpec_('value', 'string', 0),
        'key': MemberSpec_('key', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None, key=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
        self.key = _cast(None, key)
    def factory(*args_, **kwargs_):
        if map.subclass:
            return map.subclass(*args_, **kwargs_)
        else:
            return map(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='map', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='map')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='map', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='map'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='map', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='map'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class map


class name_formats(GeneratedsSuper):
    member_data_items_ = {
        'format': MemberSpec_('format', 'format', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, format=None):
        self.original_tagname_ = None
        if format is None:
            self.format = []
        else:
            self.format = format
    def factory(*args_, **kwargs_):
        if name_formats.subclass:
            return name_formats.subclass(*args_, **kwargs_)
        else:
            return name_formats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def add_format(self, value): self.format.append(value)
    def insert_format_at(self, index, value): self.format.insert(index, value)
    def replace_format_at(self, index, value): self.format[index] = value
    def hasContent_(self):
        if (
            self.format
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='name-formats', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='name-formats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='name-formats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='name-formats'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='name-formats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for format_ in self.format:
            format_.export(outfile, level, namespace_='gramps:', name_='format', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='name-formats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('format=[\n')
        level += 1
        for format_ in self.format:
            showIndent(outfile, level)
            outfile.write('model_.format(\n')
            format_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'format'
# end class name_formats


class format(GeneratedsSuper):
    member_data_items_ = {
        'active': MemberSpec_('active', 'string', 0),
        'number': MemberSpec_('number', 'string', 0),
        'fmt_str': MemberSpec_('fmt_str', 'string', 0),
        'name': MemberSpec_('name', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, active=None, number=None, fmt_str=None, name=None):
        self.original_tagname_ = None
        self.active = _cast(None, active)
        self.number = _cast(None, number)
        self.fmt_str = _cast(None, fmt_str)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if format.subclass:
            return format.subclass(*args_, **kwargs_)
        else:
            return format(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_active(self): return self.active
    def set_active(self, active): self.active = active
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_fmt_str(self): return self.fmt_str
    def set_fmt_str(self, fmt_str): self.fmt_str = fmt_str
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='format', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='format')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='format', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='format'):
        if self.active is not None and 'active' not in already_processed:
            already_processed.add('active')
            outfile.write(' active=%s' % (self.gds_format_string(quote_attrib(self.active).encode(ExternalEncoding), input_name='active'), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_format_string(quote_attrib(self.number).encode(ExternalEncoding), input_name='number'), ))
        if self.fmt_str is not None and 'fmt_str' not in already_processed:
            already_processed.add('fmt_str')
            outfile.write(' fmt_str=%s' % (self.gds_format_string(quote_attrib(self.fmt_str).encode(ExternalEncoding), input_name='fmt_str'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='format', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='format'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.active is not None and 'active' not in already_processed:
            already_processed.add('active')
            showIndent(outfile, level)
            outfile.write('active="%s",\n' % (self.active,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number="%s",\n' % (self.number,))
        if self.fmt_str is not None and 'fmt_str' not in already_processed:
            already_processed.add('fmt_str')
            showIndent(outfile, level)
            outfile.write('fmt_str="%s",\n' % (self.fmt_str,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.add('active')
            self.active = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
        value = find_attr_value_('fmt_str', node)
        if value is not None and 'fmt_str' not in already_processed:
            already_processed.add('fmt_str')
            self.fmt_str = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class format


class daterange(GeneratedsSuper):
    member_data_items_ = {
        'cformat': MemberSpec_('cformat', 'string', 0),
        'stop': MemberSpec_('stop', 'string', 0),
        'dualdated': MemberSpec_('dualdated', 'string', 0),
        'start': MemberSpec_('start', 'string', 0),
        'newyear': MemberSpec_('newyear', 'string', 0),
        'quality': MemberSpec_('quality', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cformat=None, stop=None, dualdated=None, start=None, newyear=None, quality=None):
        self.original_tagname_ = None
        self.cformat = _cast(None, cformat)
        self.stop = _cast(None, stop)
        self.dualdated = _cast(None, dualdated)
        self.start = _cast(None, start)
        self.newyear = _cast(None, newyear)
        self.quality = _cast(None, quality)
    def factory(*args_, **kwargs_):
        if daterange.subclass:
            return daterange.subclass(*args_, **kwargs_)
        else:
            return daterange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cformat(self): return self.cformat
    def set_cformat(self, cformat): self.cformat = cformat
    def get_stop(self): return self.stop
    def set_stop(self, stop): self.stop = stop
    def get_dualdated(self): return self.dualdated
    def set_dualdated(self, dualdated): self.dualdated = dualdated
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_newyear(self): return self.newyear
    def set_newyear(self, newyear): self.newyear = newyear
    def get_quality(self): return self.quality
    def set_quality(self, quality): self.quality = quality
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='daterange', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='daterange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='daterange'):
        if self.cformat is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            outfile.write(' cformat=%s' % (self.gds_format_string(quote_attrib(self.cformat).encode(ExternalEncoding), input_name='cformat'), ))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            outfile.write(' stop=%s' % (self.gds_format_string(quote_attrib(self.stop).encode(ExternalEncoding), input_name='stop'), ))
        if self.dualdated is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            outfile.write(' dualdated=%s' % (self.gds_format_string(quote_attrib(self.dualdated).encode(ExternalEncoding), input_name='dualdated'), ))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_format_string(quote_attrib(self.start).encode(ExternalEncoding), input_name='start'), ))
        if self.newyear is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            outfile.write(' newyear=%s' % (self.gds_format_string(quote_attrib(self.newyear).encode(ExternalEncoding), input_name='newyear'), ))
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            outfile.write(' quality=%s' % (self.gds_format_string(quote_attrib(self.quality).encode(ExternalEncoding), input_name='quality'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='daterange', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='daterange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cformat is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            showIndent(outfile, level)
            outfile.write('cformat="%s",\n' % (self.cformat,))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            showIndent(outfile, level)
            outfile.write('stop="%s",\n' % (self.stop,))
        if self.dualdated is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            showIndent(outfile, level)
            outfile.write('dualdated="%s",\n' % (self.dualdated,))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start="%s",\n' % (self.start,))
        if self.newyear is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            showIndent(outfile, level)
            outfile.write('newyear="%s",\n' % (self.newyear,))
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            showIndent(outfile, level)
            outfile.write('quality="%s",\n' % (self.quality,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cformat', node)
        if value is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            self.cformat = value
        value = find_attr_value_('stop', node)
        if value is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            self.stop = value
        value = find_attr_value_('dualdated', node)
        if value is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            self.dualdated = value
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
        value = find_attr_value_('newyear', node)
        if value is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            self.newyear = value
        value = find_attr_value_('quality', node)
        if value is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            self.quality = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class daterange


class datespan(GeneratedsSuper):
    member_data_items_ = {
        'cformat': MemberSpec_('cformat', 'string', 0),
        'stop': MemberSpec_('stop', 'string', 0),
        'dualdated': MemberSpec_('dualdated', 'string', 0),
        'start': MemberSpec_('start', 'string', 0),
        'newyear': MemberSpec_('newyear', 'string', 0),
        'quality': MemberSpec_('quality', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cformat=None, stop=None, dualdated=None, start=None, newyear=None, quality=None):
        self.original_tagname_ = None
        self.cformat = _cast(None, cformat)
        self.stop = _cast(None, stop)
        self.dualdated = _cast(None, dualdated)
        self.start = _cast(None, start)
        self.newyear = _cast(None, newyear)
        self.quality = _cast(None, quality)
    def factory(*args_, **kwargs_):
        if datespan.subclass:
            return datespan.subclass(*args_, **kwargs_)
        else:
            return datespan(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cformat(self): return self.cformat
    def set_cformat(self, cformat): self.cformat = cformat
    def get_stop(self): return self.stop
    def set_stop(self, stop): self.stop = stop
    def get_dualdated(self): return self.dualdated
    def set_dualdated(self, dualdated): self.dualdated = dualdated
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_newyear(self): return self.newyear
    def set_newyear(self, newyear): self.newyear = newyear
    def get_quality(self): return self.quality
    def set_quality(self, quality): self.quality = quality
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='datespan', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='datespan')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='datespan'):
        if self.cformat is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            outfile.write(' cformat=%s' % (self.gds_format_string(quote_attrib(self.cformat).encode(ExternalEncoding), input_name='cformat'), ))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            outfile.write(' stop=%s' % (self.gds_format_string(quote_attrib(self.stop).encode(ExternalEncoding), input_name='stop'), ))
        if self.dualdated is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            outfile.write(' dualdated=%s' % (self.gds_format_string(quote_attrib(self.dualdated).encode(ExternalEncoding), input_name='dualdated'), ))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_format_string(quote_attrib(self.start).encode(ExternalEncoding), input_name='start'), ))
        if self.newyear is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            outfile.write(' newyear=%s' % (self.gds_format_string(quote_attrib(self.newyear).encode(ExternalEncoding), input_name='newyear'), ))
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            outfile.write(' quality=%s' % (self.gds_format_string(quote_attrib(self.quality).encode(ExternalEncoding), input_name='quality'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='datespan', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='datespan'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cformat is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            showIndent(outfile, level)
            outfile.write('cformat="%s",\n' % (self.cformat,))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            showIndent(outfile, level)
            outfile.write('stop="%s",\n' % (self.stop,))
        if self.dualdated is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            showIndent(outfile, level)
            outfile.write('dualdated="%s",\n' % (self.dualdated,))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start="%s",\n' % (self.start,))
        if self.newyear is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            showIndent(outfile, level)
            outfile.write('newyear="%s",\n' % (self.newyear,))
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            showIndent(outfile, level)
            outfile.write('quality="%s",\n' % (self.quality,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cformat', node)
        if value is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            self.cformat = value
        value = find_attr_value_('stop', node)
        if value is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            self.stop = value
        value = find_attr_value_('dualdated', node)
        if value is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            self.dualdated = value
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
        value = find_attr_value_('newyear', node)
        if value is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            self.newyear = value
        value = find_attr_value_('quality', node)
        if value is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            self.quality = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class datespan


class dateval(GeneratedsSuper):
    member_data_items_ = {
        'cformat': MemberSpec_('cformat', 'string', 0),
        'val': MemberSpec_('val', 'string', 0),
        'type': MemberSpec_('type', 'string', 0),
        'dualdated': MemberSpec_('dualdated', 'string', 0),
        'newyear': MemberSpec_('newyear', 'string', 0),
        'quality': MemberSpec_('quality', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cformat=None, val=None, type_=None, dualdated=None, newyear=None, quality=None):
        self.original_tagname_ = None
        self.cformat = _cast(None, cformat)
        self.val = _cast(None, val)
        self.type_ = _cast(None, type_)
        self.dualdated = _cast(None, dualdated)
        self.newyear = _cast(None, newyear)
        self.quality = _cast(None, quality)
    def factory(*args_, **kwargs_):
        if dateval.subclass:
            return dateval.subclass(*args_, **kwargs_)
        else:
            return dateval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cformat(self): return self.cformat
    def set_cformat(self, cformat): self.cformat = cformat
    def get_val(self): return self.val
    def set_val(self, val): self.val = val
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_dualdated(self): return self.dualdated
    def set_dualdated(self, dualdated): self.dualdated = dualdated
    def get_newyear(self): return self.newyear
    def set_newyear(self, newyear): self.newyear = newyear
    def get_quality(self): return self.quality
    def set_quality(self, quality): self.quality = quality
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='dateval', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='dateval'):
        if self.cformat is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            outfile.write(' cformat=%s' % (self.gds_format_string(quote_attrib(self.cformat).encode(ExternalEncoding), input_name='cformat'), ))
        if self.val is not None and 'val' not in already_processed:
            already_processed.add('val')
            outfile.write(' val=%s' % (self.gds_format_string(quote_attrib(self.val).encode(ExternalEncoding), input_name='val'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.dualdated is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            outfile.write(' dualdated=%s' % (self.gds_format_string(quote_attrib(self.dualdated).encode(ExternalEncoding), input_name='dualdated'), ))
        if self.newyear is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            outfile.write(' newyear=%s' % (self.gds_format_string(quote_attrib(self.newyear).encode(ExternalEncoding), input_name='newyear'), ))
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            outfile.write(' quality=%s' % (self.gds_format_string(quote_attrib(self.quality).encode(ExternalEncoding), input_name='quality'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='dateval', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dateval'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cformat is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            showIndent(outfile, level)
            outfile.write('cformat="%s",\n' % (self.cformat,))
        if self.val is not None and 'val' not in already_processed:
            already_processed.add('val')
            showIndent(outfile, level)
            outfile.write('val="%s",\n' % (self.val,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.dualdated is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            showIndent(outfile, level)
            outfile.write('dualdated="%s",\n' % (self.dualdated,))
        if self.newyear is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            showIndent(outfile, level)
            outfile.write('newyear="%s",\n' % (self.newyear,))
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            showIndent(outfile, level)
            outfile.write('quality="%s",\n' % (self.quality,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cformat', node)
        if value is not None and 'cformat' not in already_processed:
            already_processed.add('cformat')
            self.cformat = value
        value = find_attr_value_('val', node)
        if value is not None and 'val' not in already_processed:
            already_processed.add('val')
            self.val = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('dualdated', node)
        if value is not None and 'dualdated' not in already_processed:
            already_processed.add('dualdated')
            self.dualdated = value
        value = find_attr_value_('newyear', node)
        if value is not None and 'newyear' not in already_processed:
            already_processed.add('newyear')
            self.newyear = value
        value = find_attr_value_('quality', node)
        if value is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            self.quality = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateval


class datestr(GeneratedsSuper):
    member_data_items_ = {
        'val': MemberSpec_('val', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, val=None):
        self.original_tagname_ = None
        self.val = _cast(None, val)
    def factory(*args_, **kwargs_):
        if datestr.subclass:
            return datestr.subclass(*args_, **kwargs_)
        else:
            return datestr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_val(self): return self.val
    def set_val(self, val): self.val = val
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='datestr', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='datestr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='datestr'):
        if self.val is not None and 'val' not in already_processed:
            already_processed.add('val')
            outfile.write(' val=%s' % (self.gds_format_string(quote_attrib(self.val).encode(ExternalEncoding), input_name='val'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='datestr', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='datestr'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.val is not None and 'val' not in already_processed:
            already_processed.add('val')
            showIndent(outfile, level)
            outfile.write('val="%s",\n' % (self.val,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val', node)
        if value is not None and 'val' not in already_processed:
            already_processed.add('val')
            self.val = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class datestr


class citationref(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if citationref.subclass:
            return citationref.subclass(*args_, **kwargs_)
        else:
            return citationref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='citationref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='citationref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='citationref'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='citationref', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='citationref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class citationref


class sourceref(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if sourceref.subclass:
            return sourceref.subclass(*args_, **kwargs_)
        else:
            return sourceref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='sourceref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourceref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='sourceref', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='sourceref'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='sourceref', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='sourceref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sourceref


class eventref(GeneratedsSuper):
    member_data_items_ = {
        'role': MemberSpec_('role', 'string', 0),
        'hlink': MemberSpec_('hlink', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'attribute': MemberSpec_('attribute', 'attribute', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, role=None, hlink=None, priv=None, attribute=None, noteref=None):
        self.original_tagname_ = None
        self.role = _cast(None, role)
        self.hlink = _cast(None, hlink)
        self.priv = _cast(None, priv)
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
    def factory(*args_, **kwargs_):
        if eventref.subclass:
            return eventref.subclass(*args_, **kwargs_)
        else:
            return eventref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.attribute or
            self.noteref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='eventref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='eventref', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='eventref'):
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='eventref', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_='gramps:', name_='attribute', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='eventref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            showIndent(outfile, level)
            outfile.write('role="%s",\n' % (self.role,))
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
# end class eventref


class reporef(GeneratedsSuper):
    member_data_items_ = {
        'medium': MemberSpec_('medium', 'string', 0),
        'callno': MemberSpec_('callno', 'string', 0),
        'hlink': MemberSpec_('hlink', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, medium=None, callno=None, hlink=None, priv=None, noteref=None):
        self.original_tagname_ = None
        self.medium = _cast(None, medium)
        self.callno = _cast(None, callno)
        self.hlink = _cast(None, hlink)
        self.priv = _cast(None, priv)
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
    def factory(*args_, **kwargs_):
        if reporef.subclass:
            return reporef.subclass(*args_, **kwargs_)
        else:
            return reporef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_medium(self): return self.medium
    def set_medium(self, medium): self.medium = medium
    def get_callno(self): return self.callno
    def set_callno(self, callno): self.callno = callno
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.noteref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='reporef', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reporef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='reporef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='reporef'):
        if self.medium is not None and 'medium' not in already_processed:
            already_processed.add('medium')
            outfile.write(' medium=%s' % (self.gds_format_string(quote_attrib(self.medium).encode(ExternalEncoding), input_name='medium'), ))
        if self.callno is not None and 'callno' not in already_processed:
            already_processed.add('callno')
            outfile.write(' callno=%s' % (self.gds_format_string(quote_attrib(self.callno).encode(ExternalEncoding), input_name='callno'), ))
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='reporef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='reporef'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.medium is not None and 'medium' not in already_processed:
            already_processed.add('medium')
            showIndent(outfile, level)
            outfile.write('medium="%s",\n' % (self.medium,))
        if self.callno is not None and 'callno' not in already_processed:
            already_processed.add('callno')
            showIndent(outfile, level)
            outfile.write('callno="%s",\n' % (self.callno,))
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('medium', node)
        if value is not None and 'medium' not in already_processed:
            already_processed.add('medium')
            self.medium = value
        value = find_attr_value_('callno', node)
        if value is not None and 'callno' not in already_processed:
            already_processed.add('callno')
            self.callno = value
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
# end class reporef


class noteref(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if noteref.subclass:
            return noteref.subclass(*args_, **kwargs_)
        else:
            return noteref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='noteref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='noteref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='noteref'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='noteref', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='noteref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class noteref


class tagref(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if tagref.subclass:
            return tagref.subclass(*args_, **kwargs_)
        else:
            return tagref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='tagref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tagref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='tagref', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='tagref'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='tagref', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='tagref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tagref


class page(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if page.subclass:
            return page.subclass(*args_, **kwargs_)
        else:
            return page(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='page', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='page')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='page'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='page', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='page'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class page


class confidence(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if confidence.subclass:
            return confidence.subclass(*args_, **kwargs_)
        else:
            return confidence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='confidence', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='confidence')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='confidence'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='confidence', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='confidence'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class confidence


class attribute(GeneratedsSuper):
    member_data_items_ = {
        'type': MemberSpec_('type', 'string', 0),
        'value': MemberSpec_('value', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None, priv=None, citationref=None, noteref=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
        self.priv = _cast(None, priv)
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
    def factory(*args_, **kwargs_):
        if attribute.subclass:
            return attribute.subclass(*args_, **kwargs_)
        else:
            return attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.citationref or
            self.noteref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='attribute', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='attribute', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='attribute'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='attribute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attribute'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
# end class attribute


class srcattribute(GeneratedsSuper):
    member_data_items_ = {
        'type': MemberSpec_('type', 'string', 0),
        'value': MemberSpec_('value', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None, priv=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
        self.priv = _cast(None, priv)
    def factory(*args_, **kwargs_):
        if srcattribute.subclass:
            return srcattribute.subclass(*args_, **kwargs_)
        else:
            return srcattribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='srcattribute', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='srcattribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='srcattribute', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='srcattribute'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='srcattribute', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='srcattribute'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class srcattribute


class place(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if place.subclass:
            return place.subclass(*args_, **kwargs_)
        else:
            return place(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='place', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='place')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='place', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='place'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='place', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='place'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class place


class cause(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cause.subclass:
            return cause.subclass(*args_, **kwargs_)
        else:
            return cause(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='cause', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cause')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='cause'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='cause', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cause'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class cause


class description(GeneratedsSuper):
    member_data_items_ = {
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='description', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='description'):
        pass
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='description', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class description


class url(GeneratedsSuper):
    member_data_items_ = {
        'href': MemberSpec_('href', 'string', 0),
        'type': MemberSpec_('type', 'string', 0),
        'description': MemberSpec_('description', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, href=None, type_=None, description=None, priv=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.description = _cast(None, description)
        self.priv = _cast(None, priv)
    def factory(*args_, **kwargs_):
        if url.subclass:
            return url.subclass(*args_, **kwargs_)
        else:
            return url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='url', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='url')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='url', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='url'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='url', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='url'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class url


class objref(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'region': MemberSpec_('region', 'region', 0),
        'attribute': MemberSpec_('attribute', 'attribute', 1),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None, priv=None, region=None, attribute=None, citationref=None, noteref=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
        self.priv = _cast(None, priv)
        self.region = region
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
    def factory(*args_, **kwargs_):
        if objref.subclass:
            return objref.subclass(*args_, **kwargs_)
        else:
            return objref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.region is not None or
            self.attribute or
            self.citationref or
            self.noteref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='objref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='objref', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='objref'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='objref', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.region is not None:
            self.region.export(outfile, level, namespace_='gramps:', name_='region', pretty_print=pretty_print)
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_='gramps:', name_='attribute', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='objref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.region is not None:
            showIndent(outfile, level)
            outfile.write('region=model_.region(\n')
            self.region.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'region':
            obj_ = region.factory()
            obj_.build(child_)
            self.region = obj_
            obj_.original_tagname_ = 'region'
        elif nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
# end class objref


class placeref(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
        'daterange': MemberSpec_('daterange', 'daterange', 0),
        'datespan': MemberSpec_('datespan', 'datespan', 0),
        'dateval': MemberSpec_('dateval', 'dateval', 0),
        'datestr': MemberSpec_('datestr', 'datestr', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None, daterange=None, datespan=None, dateval=None, datestr=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
        self.daterange = daterange
        self.datespan = datespan
        self.dateval = dateval
        self.datestr = datestr
    def factory(*args_, **kwargs_):
        if placeref.subclass:
            return placeref.subclass(*args_, **kwargs_)
        else:
            return placeref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_daterange(self): return self.daterange
    def set_daterange(self, daterange): self.daterange = daterange
    def get_datespan(self): return self.datespan
    def set_datespan(self, datespan): self.datespan = datespan
    def get_dateval(self): return self.dateval
    def set_dateval(self, dateval): self.dateval = dateval
    def get_datestr(self): return self.datestr
    def set_datestr(self, datestr): self.datestr = datestr
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (
            self.daterange is not None or
            self.datespan is not None or
            self.dateval is not None or
            self.datestr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='placeref', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='placeref')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='placeref', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='placeref'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='placeref', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.daterange is not None:
            self.daterange.export(outfile, level, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
        if self.datespan is not None:
            self.datespan.export(outfile, level, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
        if self.dateval is not None:
            self.dateval.export(outfile, level, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
        if self.datestr is not None:
            self.datestr.export(outfile, level, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='placeref'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.daterange is not None:
            showIndent(outfile, level)
            outfile.write('daterange=model_.daterange(\n')
            self.daterange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datespan is not None:
            showIndent(outfile, level)
            outfile.write('datespan=model_.datespan(\n')
            self.datespan.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateval is not None:
            showIndent(outfile, level)
            outfile.write('dateval=model_.dateval(\n')
            self.dateval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datestr is not None:
            showIndent(outfile, level)
            outfile.write('datestr=model_.datestr(\n')
            self.datestr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'daterange':
            obj_ = daterange.factory()
            obj_.build(child_)
            self.daterange = obj_
            obj_.original_tagname_ = 'daterange'
        elif nodeName_ == 'datespan':
            obj_ = datespan.factory()
            obj_.build(child_)
            self.datespan = obj_
            obj_.original_tagname_ = 'datespan'
        elif nodeName_ == 'dateval':
            obj_ = dateval.factory()
            obj_.build(child_)
            self.dateval = obj_
            obj_.original_tagname_ = 'dateval'
        elif nodeName_ == 'datestr':
            obj_ = datestr.factory()
            obj_.build(child_)
            self.datestr = obj_
            obj_.original_tagname_ = 'datestr'
# end class placeref


class region(GeneratedsSuper):
    member_data_items_ = {
        'corner1_x': MemberSpec_('corner1_x', 'string', 0),
        'corner1_y': MemberSpec_('corner1_y', 'string', 0),
        'corner2_y': MemberSpec_('corner2_y', 'string', 0),
        'corner2_x': MemberSpec_('corner2_x', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, corner1_x=None, corner1_y=None, corner2_y=None, corner2_x=None):
        self.original_tagname_ = None
        self.corner1_x = _cast(None, corner1_x)
        self.corner1_y = _cast(None, corner1_y)
        self.corner2_y = _cast(None, corner2_y)
        self.corner2_x = _cast(None, corner2_x)
    def factory(*args_, **kwargs_):
        if region.subclass:
            return region.subclass(*args_, **kwargs_)
        else:
            return region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_corner1_x(self): return self.corner1_x
    def set_corner1_x(self, corner1_x): self.corner1_x = corner1_x
    def get_corner1_y(self): return self.corner1_y
    def set_corner1_y(self, corner1_y): self.corner1_y = corner1_y
    def get_corner2_y(self): return self.corner2_y
    def set_corner2_y(self, corner2_y): self.corner2_y = corner2_y
    def get_corner2_x(self): return self.corner2_x
    def set_corner2_x(self, corner2_x): self.corner2_x = corner2_x
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='region', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='region')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='region', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='region'):
        if self.corner1_x is not None and 'corner1_x' not in already_processed:
            already_processed.add('corner1_x')
            outfile.write(' corner1_x=%s' % (self.gds_format_string(quote_attrib(self.corner1_x).encode(ExternalEncoding), input_name='corner1_x'), ))
        if self.corner1_y is not None and 'corner1_y' not in already_processed:
            already_processed.add('corner1_y')
            outfile.write(' corner1_y=%s' % (self.gds_format_string(quote_attrib(self.corner1_y).encode(ExternalEncoding), input_name='corner1_y'), ))
        if self.corner2_y is not None and 'corner2_y' not in already_processed:
            already_processed.add('corner2_y')
            outfile.write(' corner2_y=%s' % (self.gds_format_string(quote_attrib(self.corner2_y).encode(ExternalEncoding), input_name='corner2_y'), ))
        if self.corner2_x is not None and 'corner2_x' not in already_processed:
            already_processed.add('corner2_x')
            outfile.write(' corner2_x=%s' % (self.gds_format_string(quote_attrib(self.corner2_x).encode(ExternalEncoding), input_name='corner2_x'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='region', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='region'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.corner1_x is not None and 'corner1_x' not in already_processed:
            already_processed.add('corner1_x')
            showIndent(outfile, level)
            outfile.write('corner1_x="%s",\n' % (self.corner1_x,))
        if self.corner1_y is not None and 'corner1_y' not in already_processed:
            already_processed.add('corner1_y')
            showIndent(outfile, level)
            outfile.write('corner1_y="%s",\n' % (self.corner1_y,))
        if self.corner2_y is not None and 'corner2_y' not in already_processed:
            already_processed.add('corner2_y')
            showIndent(outfile, level)
            outfile.write('corner2_y="%s",\n' % (self.corner2_y,))
        if self.corner2_x is not None and 'corner2_x' not in already_processed:
            already_processed.add('corner2_x')
            showIndent(outfile, level)
            outfile.write('corner2_x="%s",\n' % (self.corner2_x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('corner1_x', node)
        if value is not None and 'corner1_x' not in already_processed:
            already_processed.add('corner1_x')
            self.corner1_x = value
        value = find_attr_value_('corner1_y', node)
        if value is not None and 'corner1_y' not in already_processed:
            already_processed.add('corner1_y')
            self.corner1_y = value
        value = find_attr_value_('corner2_y', node)
        if value is not None and 'corner2_y' not in already_processed:
            already_processed.add('corner2_y')
            self.corner2_y = value
        value = find_attr_value_('corner2_x', node)
        if value is not None and 'corner2_x' not in already_processed:
            already_processed.add('corner2_x')
            self.corner2_x = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class region


class data_item(GeneratedsSuper):
    member_data_items_ = {
        'value': MemberSpec_('value', 'string', 0),
        'key': MemberSpec_('key', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, value=None, key=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.key = _cast(None, key)
    def factory(*args_, **kwargs_):
        if data_item.subclass:
            return data_item.subclass(*args_, **kwargs_)
        else:
            return data_item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='data_item', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='data_item')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='data_item', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='data_item'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='data_item', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='data_item'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class data_item


class lds_ord(GeneratedsSuper):
    member_data_items_ = {
        'type': MemberSpec_('type', 'string', 0),
        'priv': MemberSpec_('priv', 'string', 0),
        'daterange': MemberSpec_('daterange', 'daterange', 0),
        'datespan': MemberSpec_('datespan', 'datespan', 0),
        'dateval': MemberSpec_('dateval', 'dateval', 0),
        'datestr': MemberSpec_('datestr', 'datestr', 0),
        'temple': MemberSpec_('temple', 'temple', 0),
        'place': MemberSpec_('place', 'place', 0),
        'status': MemberSpec_('status', 'status', 0),
        'sealed_to': MemberSpec_('sealed_to', 'sealed_to', 0),
        'noteref': MemberSpec_('noteref', 'noteref', 1),
        'citationref': MemberSpec_('citationref', 'citationref', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, priv=None, daterange=None, datespan=None, dateval=None, datestr=None, temple=None, place=None, status=None, sealed_to=None, noteref=None, citationref=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.priv = _cast(None, priv)
        self.daterange = daterange
        self.datespan = datespan
        self.dateval = dateval
        self.datestr = datestr
        self.temple = temple
        self.place = place
        self.status = status
        self.sealed_to = sealed_to
        if noteref is None:
            self.noteref = []
        else:
            self.noteref = noteref
        if citationref is None:
            self.citationref = []
        else:
            self.citationref = citationref
    def factory(*args_, **kwargs_):
        if lds_ord.subclass:
            return lds_ord.subclass(*args_, **kwargs_)
        else:
            return lds_ord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_daterange(self): return self.daterange
    def set_daterange(self, daterange): self.daterange = daterange
    def get_datespan(self): return self.datespan
    def set_datespan(self, datespan): self.datespan = datespan
    def get_dateval(self): return self.dateval
    def set_dateval(self, dateval): self.dateval = dateval
    def get_datestr(self): return self.datestr
    def set_datestr(self, datestr): self.datestr = datestr
    def get_temple(self): return self.temple
    def set_temple(self, temple): self.temple = temple
    def get_place(self): return self.place
    def set_place(self, place): self.place = place
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_sealed_to(self): return self.sealed_to
    def set_sealed_to(self, sealed_to): self.sealed_to = sealed_to
    def get_noteref(self): return self.noteref
    def set_noteref(self, noteref): self.noteref = noteref
    def add_noteref(self, value): self.noteref.append(value)
    def insert_noteref_at(self, index, value): self.noteref.insert(index, value)
    def replace_noteref_at(self, index, value): self.noteref[index] = value
    def get_citationref(self): return self.citationref
    def set_citationref(self, citationref): self.citationref = citationref
    def add_citationref(self, value): self.citationref.append(value)
    def insert_citationref_at(self, index, value): self.citationref.insert(index, value)
    def replace_citationref_at(self, index, value): self.citationref[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_priv(self): return self.priv
    def set_priv(self, priv): self.priv = priv
    def hasContent_(self):
        if (
            self.daterange is not None or
            self.datespan is not None or
            self.dateval is not None or
            self.datestr is not None or
            self.temple is not None or
            self.place is not None or
            self.status is not None or
            self.sealed_to is not None or
            self.noteref or
            self.citationref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='lds_ord', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lds_ord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='lds_ord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='lds_ord'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            outfile.write(' priv=%s' % (self.gds_format_string(quote_attrib(self.priv).encode(ExternalEncoding), input_name='priv'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='lds_ord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.daterange is not None:
            self.daterange.export(outfile, level, namespace_='gramps:', name_='daterange', pretty_print=pretty_print)
        if self.datespan is not None:
            self.datespan.export(outfile, level, namespace_='gramps:', name_='datespan', pretty_print=pretty_print)
        if self.dateval is not None:
            self.dateval.export(outfile, level, namespace_='gramps:', name_='dateval', pretty_print=pretty_print)
        if self.datestr is not None:
            self.datestr.export(outfile, level, namespace_='gramps:', name_='datestr', pretty_print=pretty_print)
        if self.temple is not None:
            self.temple.export(outfile, level, namespace_='gramps:', name_='temple', pretty_print=pretty_print)
        if self.place is not None:
            self.place.export(outfile, level, namespace_='gramps:', name_='place', pretty_print=pretty_print)
        if self.status is not None:
            self.status.export(outfile, level, namespace_='gramps:', name_='status', pretty_print=pretty_print)
        if self.sealed_to is not None:
            self.sealed_to.export(outfile, level, namespace_='gramps:', name_='sealed_to', pretty_print=pretty_print)
        for noteref_ in self.noteref:
            noteref_.export(outfile, level, namespace_='gramps:', name_='noteref', pretty_print=pretty_print)
        for citationref_ in self.citationref:
            citationref_.export(outfile, level, namespace_='gramps:', name_='citationref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='lds_ord'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.priv is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            showIndent(outfile, level)
            outfile.write('priv="%s",\n' % (self.priv,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.daterange is not None:
            showIndent(outfile, level)
            outfile.write('daterange=model_.daterange(\n')
            self.daterange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datespan is not None:
            showIndent(outfile, level)
            outfile.write('datespan=model_.datespan(\n')
            self.datespan.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateval is not None:
            showIndent(outfile, level)
            outfile.write('dateval=model_.dateval(\n')
            self.dateval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.datestr is not None:
            showIndent(outfile, level)
            outfile.write('datestr=model_.datestr(\n')
            self.datestr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.temple is not None:
            showIndent(outfile, level)
            outfile.write('temple=model_.temple(\n')
            self.temple.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.place is not None:
            showIndent(outfile, level)
            outfile.write('place=model_.place(\n')
            self.place.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=model_.status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sealed_to is not None:
            showIndent(outfile, level)
            outfile.write('sealed_to=model_.sealed_to(\n')
            self.sealed_to.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('noteref=[\n')
        level += 1
        for noteref_ in self.noteref:
            showIndent(outfile, level)
            outfile.write('model_.noteref(\n')
            noteref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citationref=[\n')
        level += 1
        for citationref_ in self.citationref:
            showIndent(outfile, level)
            outfile.write('model_.citationref(\n')
            citationref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('priv', node)
        if value is not None and 'priv' not in already_processed:
            already_processed.add('priv')
            self.priv = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'daterange':
            obj_ = daterange.factory()
            obj_.build(child_)
            self.daterange = obj_
            obj_.original_tagname_ = 'daterange'
        elif nodeName_ == 'datespan':
            obj_ = datespan.factory()
            obj_.build(child_)
            self.datespan = obj_
            obj_.original_tagname_ = 'datespan'
        elif nodeName_ == 'dateval':
            obj_ = dateval.factory()
            obj_.build(child_)
            self.dateval = obj_
            obj_.original_tagname_ = 'dateval'
        elif nodeName_ == 'datestr':
            obj_ = datestr.factory()
            obj_.build(child_)
            self.datestr = obj_
            obj_.original_tagname_ = 'datestr'
        elif nodeName_ == 'temple':
            obj_ = temple.factory()
            obj_.build(child_)
            self.temple = obj_
            obj_.original_tagname_ = 'temple'
        elif nodeName_ == 'place':
            obj_ = place.factory()
            obj_.build(child_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'sealed_to':
            obj_ = sealed_to.factory()
            obj_.build(child_)
            self.sealed_to = obj_
            obj_.original_tagname_ = 'sealed_to'
        elif nodeName_ == 'noteref':
            obj_ = noteref.factory()
            obj_.build(child_)
            self.noteref.append(obj_)
            obj_.original_tagname_ = 'noteref'
        elif nodeName_ == 'citationref':
            obj_ = citationref.factory()
            obj_.build(child_)
            self.citationref.append(obj_)
            obj_.original_tagname_ = 'citationref'
# end class lds_ord


class temple(GeneratedsSuper):
    member_data_items_ = {
        'val': MemberSpec_('val', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, val=None):
        self.original_tagname_ = None
        self.val = _cast(None, val)
    def factory(*args_, **kwargs_):
        if temple.subclass:
            return temple.subclass(*args_, **kwargs_)
        else:
            return temple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_val(self): return self.val
    def set_val(self, val): self.val = val
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='temple', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='temple')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='temple', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='temple'):
        if self.val is not None and 'val' not in already_processed:
            already_processed.add('val')
            outfile.write(' val=%s' % (self.gds_format_string(quote_attrib(self.val).encode(ExternalEncoding), input_name='val'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='temple', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='temple'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.val is not None and 'val' not in already_processed:
            already_processed.add('val')
            showIndent(outfile, level)
            outfile.write('val="%s",\n' % (self.val,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val', node)
        if value is not None and 'val' not in already_processed:
            already_processed.add('val')
            self.val = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class temple


class status(GeneratedsSuper):
    member_data_items_ = {
        'val': MemberSpec_('val', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, val=None):
        self.original_tagname_ = None
        self.val = _cast(None, val)
    def factory(*args_, **kwargs_):
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_val(self): return self.val
    def set_val(self, val): self.val = val
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='status', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='status')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='status', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='status'):
        if self.val is not None and 'val' not in already_processed:
            already_processed.add('val')
            outfile.write(' val=%s' % (self.gds_format_string(quote_attrib(self.val).encode(ExternalEncoding), input_name='val'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='status', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='status'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.val is not None and 'val' not in already_processed:
            already_processed.add('val')
            showIndent(outfile, level)
            outfile.write('val="%s",\n' % (self.val,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val', node)
        if value is not None and 'val' not in already_processed:
            already_processed.add('val')
            self.val = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class status


class sealed_to(GeneratedsSuper):
    member_data_items_ = {
        'hlink': MemberSpec_('hlink', 'string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hlink=None):
        self.original_tagname_ = None
        self.hlink = _cast(None, hlink)
    def factory(*args_, **kwargs_):
        if sealed_to.subclass:
            return sealed_to.subclass(*args_, **kwargs_)
        else:
            return sealed_to(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hlink(self): return self.hlink
    def set_hlink(self, hlink): self.hlink = hlink
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='gramps:', name_='sealed_to', namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sealed_to')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='gramps:', name_='sealed_to', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='gramps:', name_='sealed_to'):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            outfile.write(' hlink=%s' % (self.gds_format_string(quote_attrib(self.hlink).encode(ExternalEncoding), input_name='hlink'), ))
    def exportChildren(self, outfile, level, namespace_='gramps:', name_='sealed_to', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='sealed_to'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hlink is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            showIndent(outfile, level)
            outfile.write('hlink="%s",\n' % (self.hlink,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hlink', node)
        if value is not None and 'hlink' not in already_processed:
            already_processed.add('hlink')
            self.hlink = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sealed_to


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = etree_.ETCompatXMLParser(strip_cdata=False)
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'database'
        rootClass = database
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = etree_.ETCompatXMLParser(strip_cdata=False)
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'database'
        rootClass = database
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = etree_.ETCompatXMLParser(strip_cdata=False)
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'database'
        rootClass = database
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:gramps="http://gramps-project.org/xml/1.7.1/"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = etree_.ETCompatXMLParser(strip_cdata=False)
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'database'
        rootClass = database
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from dic_lib import *\n\n')
        sys.stdout.write('import dic_lib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "address",
    "attribute",
    "bookmark",
    "bookmarks",
    "call",
    "cause",
    "childof",
    "childref",
    "citation",
    "citationref",
    "citations",
    "city",
    "code",
    "confidence",
    "coord",
    "country",
    "county",
    "created",
    "data_item",
    "database",
    "daterange",
    "datespan",
    "datestr",
    "dateval",
    "description",
    "event",
    "eventref",
    "events",
    "families",
    "family",
    "familynick",
    "father",
    "file",
    "first",
    "format",
    "gender",
    "group",
    "header",
    "lds_ord",
    "locality",
    "location",
    "map",
    "mediapath",
    "mother",
    "name",
    "name_formats",
    "namemaps",
    "nick",
    "note",
    "noteref",
    "notes",
    "object",
    "objects",
    "objref",
    "page",
    "parentin",
    "people",
    "person",
    "personref",
    "phone",
    "place",
    "placeobj",
    "placeref",
    "places",
    "pname",
    "postal",
    "ptitle",
    "range_",
    "region",
    "rel",
    "reporef",
    "repositories",
    "repository",
    "resaddr",
    "rescity",
    "rescountry",
    "researcher",
    "resemail",
    "reslocality",
    "resname",
    "resphone",
    "respostal",
    "resstate",
    "rname",
    "sabbrev",
    "sauthor",
    "sealed_to",
    "source",
    "sourceref",
    "sources",
    "spubinfo",
    "srcattribute",
    "state",
    "status",
    "stitle",
    "street",
    "style",
    "suffix",
    "surname",
    "tag",
    "tagref",
    "tags",
    "temple",
    "text",
    "title",
    "type_",
    "url"
]
